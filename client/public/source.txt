# GEMIN-EYE — FULL SOURCE CODE
# AI-Powered Customer Acquisition Platform
# https://gemin-eye.com
# Generated: 2026-02-15T15:47:00Z
# Paste this URL into any AI (Claude, ChatGPT, etc.) for code review.
# URL: https://gemin-eye.com/source.txt
############################################################

============================================================
FILE: shared/schema.ts (151 lines)
============================================================
import { sql, relations } from "drizzle-orm";
import { pgTable, text, varchar, serial, integer, timestamp, boolean, jsonb, index } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export * from "./models/auth";
export * from "./models/chat";

export const businesses = pgTable("businesses", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").notNull(),
  name: text("name").notNull(),
  type: text("type").notNull(),
  contactEmail: text("contact_email"),
  contactPhone: text("contact_phone"),
  website: text("website"),
  targetAudience: text("target_audience").notNull(),
  coreOffering: text("core_offering").notNull(),
  preferredTone: text("preferred_tone").notNull().default("empathetic"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_businesses_user_id").on(table.userId),
]);

export const businessesRelations = relations(businesses, ({ many }) => ({
  campaigns: many(campaigns),
}));

export const campaigns = pgTable("campaigns", {
  id: serial("id").primaryKey(),
  businessId: integer("business_id").notNull().references(() => businesses.id, { onDelete: "cascade" }),
  name: text("name").notNull(),
  platform: text("platform").notNull(),
  status: text("status").notNull().default("active"),
  strategy: text("strategy"),
  targetGroups: jsonb("target_groups").$type<string[]>().default([]),
  keywords: jsonb("keywords").$type<string[]>().default([]),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_campaigns_business_id").on(table.businessId),
]);

export const campaignsRelations = relations(campaigns, ({ one, many }) => ({
  business: one(businesses, {
    fields: [campaigns.businessId],
    references: [businesses.id],
  }),
  leads: many(leads),
}));

export const leads = pgTable("leads", {
  id: serial("id").primaryKey(),
  campaignId: integer("campaign_id").notNull().references(() => campaigns.id, { onDelete: "cascade" }),
  platform: text("platform").notNull(),
  groupName: text("group_name").notNull(),
  authorName: text("author_name").notNull(),
  originalPost: text("original_post").notNull(),
  postUrl: text("post_url"),
  intentScore: integer("intent_score").notNull().default(0),
  status: text("status").notNull().default("new"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_leads_campaign_id").on(table.campaignId),
  index("idx_leads_created_at").on(table.createdAt),
]);

export const leadsRelations = relations(leads, ({ one, many }) => ({
  campaign: one(campaigns, {
    fields: [leads.campaignId],
    references: [campaigns.id],
  }),
  responses: many(aiResponses),
}));

export const aiResponses = pgTable("ai_responses", {
  id: serial("id").primaryKey(),
  leadId: integer("lead_id").notNull().references(() => leads.id, { onDelete: "cascade" }),
  content: text("content").notNull(),
  status: text("status").notNull().default("pending"),
  approvedAt: timestamp("approved_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => [
  index("idx_ai_responses_lead_id").on(table.leadId),
  index("idx_ai_responses_status").on(table.status),
]);

export const aiResponsesRelations = relations(aiResponses, ({ one }) => ({
  lead: one(leads, {
    fields: [aiResponses.leadId],
    references: [leads.id],
  }),
}));

export const insertBusinessSchema = createInsertSchema(businesses).omit({
  id: true,
  createdAt: true,
});

export const insertCampaignSchema = createInsertSchema(campaigns).omit({
  id: true,
  createdAt: true,
});

export const insertLeadSchema = createInsertSchema(leads).omit({
  id: true,
  createdAt: true,
});

export const responseFeedback = pgTable("response_feedback", {
  id: serial("id").primaryKey(),
  responseId: integer("response_id").notNull().references(() => aiResponses.id, { onDelete: "cascade" }),
  feedback: text("feedback").notNull(),
  reason: text("reason"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export const responseFeedbackRelations = relations(responseFeedback, ({ one }) => ({
  response: one(aiResponses, {
    fields: [responseFeedback.responseId],
    references: [aiResponses.id],
  }),
}));

export const insertAiResponseSchema = createInsertSchema(aiResponses).omit({
  id: true,
  createdAt: true,
  approvedAt: true,
});

export const insertResponseFeedbackSchema = createInsertSchema(responseFeedback).omit({
  id: true,
  createdAt: true,
});

export const seenItems = pgTable("seen_items", {
  id: serial("id").primaryKey(),
  dedupKey: text("dedup_key").notNull().unique(),
  source: text("source").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type Business = typeof businesses.$inferSelect;
export type InsertBusiness = z.infer<typeof insertBusinessSchema>;
export type Campaign = typeof campaigns.$inferSelect;
export type InsertCampaign = z.infer<typeof insertCampaignSchema>;
export type Lead = typeof leads.$inferSelect;
export type InsertLead = z.infer<typeof insertLeadSchema>;
export type AiResponse = typeof aiResponses.$inferSelect;
export type InsertAiResponse = z.infer<typeof insertAiResponseSchema>;
export type ResponseFeedback = typeof responseFeedback.$inferSelect;
export type InsertResponseFeedback = z.infer<typeof insertResponseFeedbackSchema>;


============================================================
FILE: shared/models/auth.ts (29 lines)
============================================================
import { sql } from "drizzle-orm";
import { index, jsonb, pgTable, timestamp, varchar } from "drizzle-orm/pg-core";

// Session storage table.
// (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)]
);

// User storage table.
// (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.
export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: varchar("email").unique(),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export type UpsertUser = typeof users.$inferInsert;
export type User = typeof users.$inferSelect;


============================================================
FILE: shared/models/chat.ts (34 lines)
============================================================
import { pgTable, serial, integer, text, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { sql } from "drizzle-orm";

export const conversations = pgTable("conversations", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull(),
});

export const messages = pgTable("messages", {
  id: serial("id").primaryKey(),
  conversationId: integer("conversation_id").notNull().references(() => conversations.id, { onDelete: "cascade" }),
  role: text("role").notNull(),
  content: text("content").notNull(),
  createdAt: timestamp("created_at").default(sql`CURRENT_TIMESTAMP`).notNull(),
});

export const insertConversationSchema = createInsertSchema(conversations).omit({
  id: true,
  createdAt: true,
});

export const insertMessageSchema = createInsertSchema(messages).omit({
  id: true,
  createdAt: true,
});

export type Conversation = typeof conversations.$inferSelect;
export type InsertConversation = z.infer<typeof insertConversationSchema>;
export type Message = typeof messages.$inferSelect;
export type InsertMessage = z.infer<typeof insertMessageSchema>;



============================================================
FILE: server/index.ts (133 lines)
============================================================
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { serveStatic } from "./static";
import { createServer } from "http";
import { execSync } from "child_process";
import fs from "fs";

const requiredEnvVars = ["DATABASE_URL", "SESSION_SECRET"];
const optionalEnvVars = ["TELEGRAM_BOT_TOKEN", "AI_INTEGRATIONS_GEMINI_API_KEY"];

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    console.error(`FATAL: Missing required environment variable: ${envVar}`);
    process.exit(1);
  }
}

for (const envVar of optionalEnvVars) {
  if (!process.env[envVar]) {
    console.warn(`WARNING: Missing optional environment variable: ${envVar} — some features will be disabled`);
  }
}

const app = express();
const httpServer = createServer(app);

declare module "http" {
  interface IncomingMessage {
    rawBody: unknown;
  }
}

app.use(
  express.json({
    verify: (req, _res, buf) => {
      req.rawBody = buf;
    },
  }),
);

app.use(express.urlencoded({ extended: false }));

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  try {
    if (fs.existsSync("generate-source-dump.sh")) {
      execSync("bash generate-source-dump.sh", { stdio: "pipe" });
    }
  } catch {}

  await registerRoutes(httpServer, app);

  const { seedDatabase } = await import("./seed");
  await seedDatabase().catch((e) => console.error("Seed error:", e));

  const { syncKeywords } = await import("./sync-keywords");
  await syncKeywords().catch((e) => console.error("Keyword sync error:", e));

  app.use((err: any, _req: Request, res: Response, next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    console.error("Internal Server Error:", err);

    if (res.headersSent) {
      return next(err);
    }

    return res.status(status).json({ message });
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (process.env.NODE_ENV === "production") {
    serveStatic(app);
  } else {
    const { setupVite } = await import("./vite");
    await setupVite(httpServer, app);
  }

  // ALWAYS serve the app on the port specified in the environment variable PORT
  // Other ports are firewalled. Default to 5000 if not specified.
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = parseInt(process.env.PORT || "5000", 10);
  httpServer.listen(
    {
      port,
      host: "0.0.0.0",
      reusePort: true,
    },
    () => {
      log(`serving on port ${port}`);
    },
  );
})();


============================================================
FILE: server/routes.ts (472 lines)
============================================================
import type { Express } from "express";
import { createServer, type Server } from "http";
import fs from "fs";
import path from "path";
import { setupAuth, registerAuthRoutes, isAuthenticated } from "./replit_integrations/auth";
import { storage } from "./storage";
import { z } from "zod";
import { insertBusinessSchema } from "@shared/schema";
import { sendTelegramMessage, formatLeadNotification, formatResponseNotification } from "./telegram";
import { registerTelegramWebhook } from "./telegram-bot";
import { startRedditMonitor } from "./reddit-monitor";
import { startGoogleAlertsMonitor } from "./google-alerts-monitor";
import { SOURCE_ARCHIVE_B64 } from "./source-archive";
import { generateContent, safeParseJsonFromAI, parseAIJsonWithRetry, strategySchema, TONE_MAP } from "./utils/ai";
import { createRateLimiter } from "./utils/rate-limit";
import { registerAdminRoutes } from "./routes/admin";
import { registerScanRoutes } from "./routes/scan";

const aiRateLimit = createRateLimiter({
  name: "ai-endpoints",
  maxRequests: 10,
  windowMs: 60 * 1000,
  keyFn: (req: any) => req.user?.claims?.sub || req.ip || "unknown",
});

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  await setupAuth(app);
  registerAuthRoutes(app);

  app.get("/api/health", (_req, res) => {
    res.json({
      status: "ok",
      uptime: process.uptime(),
      timestamp: new Date().toISOString(),
    });
  });

  app.get("/api/businesses", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const biz = await storage.getBusinessesByUser(userId);
      res.json(biz);
    } catch (error) {
      console.error("Error fetching businesses:", error);
      res.status(500).json({ error: "Failed to fetch businesses" });
    }
  });

  app.post("/api/businesses", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const bodySchema = insertBusinessSchema.omit({ userId: true }).extend({
        strategy: z.object({
          platforms: z.array(z.object({ name: z.string() })),
          groups: z.array(z.string()),
          keywords: z.array(z.string()),
          sampleResponse: z.string(),
          rationale: z.string(),
        }).optional(),
      });

      const parsed = bodySchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid request", details: parsed.error.issues });
      }

      const { name, type, contactEmail, contactPhone, website, targetAudience, coreOffering, preferredTone, strategy } = parsed.data;

      const biz = await storage.createBusiness({
        userId,
        name,
        type,
        contactEmail: contactEmail || null,
        contactPhone: contactPhone || null,
        website: website || null,
        targetAudience,
        coreOffering,
        preferredTone,
      });

      if (strategy && strategy.platforms) {
        for (const platform of strategy.platforms) {
          await storage.createCampaign({
            businessId: biz.id,
            name: `${platform.name} Campaign`,
            platform: platform.name,
            status: "active",
            strategy: strategy.rationale,
            targetGroups: strategy.groups.filter((_: string, i: number) => i < 5),
            keywords: strategy.keywords,
          });
        }
      }

      res.json(biz);
    } catch (error) {
      console.error("Error creating business:", error);
      res.status(500).json({ error: "Failed to create business" });
    }
  });

  app.post("/api/strategy/generate", isAuthenticated, aiRateLimit, async (req: any, res) => {
    try {
      const strategyInputSchema = z.object({
        name: z.string().min(1),
        type: z.string().min(1),
        contactEmail: z.string().optional().default(""),
        contactPhone: z.string().optional().default(""),
        website: z.string().optional().default(""),
        location: z.string().optional().default(""),
        targetAudience: z.string().min(1),
        coreOffering: z.string().min(10),
        preferredTone: z.string().min(1),
      });

      const parsed = strategyInputSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid request", details: parsed.error.issues });
      }

      const { name, type, location, targetAudience, coreOffering, preferredTone } = parsed.data;
      const locationLine = location ? `\n- Location: ${location}` : "";

      const prompt = `You are a marketing strategist specializing in social media community engagement.

A business wants to find customers by monitoring social media groups for high-intent questions and responding helpfully.

Business Details:
- Name: ${name}
- Type/Niche: ${type}${locationLine}
- Target Audience: ${targetAudience}
- Core Offering: ${coreOffering}
- Preferred Tone: ${preferredTone}

Generate a customer acquisition strategy. Return ONLY valid JSON with this exact structure:
{
  "platforms": [{"name": "Facebook"}, {"name": "Reddit"}],
  "groups": ["Group Name 1", "Group Name 2", "r/subreddit1", "r/subreddit2", "r/subreddit3"],
  "keywords": ["keyword1", "keyword2", "keyword3", "keyword4", "keyword5", "keyword6", "keyword7", "keyword8"],
  "sampleResponse": "A sample response that the AI would post in one of these groups when someone asks a relevant question. Make it sound natural and helpful, not like an ad. About 2-3 sentences.",
  "rationale": "2-3 sentences explaining why these platforms and groups were chosen and how this strategy will help the business find customers."
}

CRITICAL RULES FOR GROUPS:
- Include at least 3-5 REAL Reddit subreddits that actually exist, prefixed with "r/" (e.g., r/chicago, r/woodworking, r/fitness).
- NEVER use placeholder names like "r/[yourcity]" or "[Your City Name]". Use REAL specific subreddit names.
- If the business has a specific local area, ALWAYS include the local city/region subreddit (e.g., r/chicago, r/austin, r/nyc).
- If the business is national or global/web-based, focus on industry and topic subreddits instead of geographic ones.
- Pick subreddits where the target audience is likely to ask questions or seek recommendations.
- Also include 2-3 real Facebook group names if applicable.
- Make the sample response sound genuinely human and helpful with a subtle recommendation. Match the preferred tone.`;

      const strategyData = await parseAIJsonWithRetry(
        async () => {
          const response = await generateContent({
            model: "gemini-2.5-pro",
            contents: prompt,
            config: { maxOutputTokens: 8192 },
          });
          return response.text;
        },
        strategySchema
      );

      if (!strategyData) {
        throw new Error("Failed to generate strategy after retries");
      }
      res.json(strategyData);
    } catch (error) {
      console.error("Error generating strategy:", error);
      res.status(500).json({ error: "Failed to generate strategy" });
    }
  });

  app.get("/api/campaigns", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const camps = await storage.getCampaignsByUser(userId);
      res.json(camps);
    } catch (error) {
      console.error("Error fetching campaigns:", error);
      res.status(500).json({ error: "Failed to fetch campaigns" });
    }
  });

  app.get("/api/leads", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const data = await storage.getDashboardData(userId);
      res.json({ leads: data.leads, responses: data.responses });
    } catch (error) {
      console.error("Error fetching leads:", error);
      res.status(500).json({ error: "Failed to fetch leads" });
    }
  });

  app.post("/api/leads/:id/generate-response", isAuthenticated, aiRateLimit, async (req: any, res) => {
    try {
      const leadId = parseInt(req.params.id);
      const userId = req.user.claims.sub;

      const camps = await storage.getCampaignsByUser(userId);
      const campaignIds = camps.map((c) => c.id);
      const allLeads = await storage.getLeadsByCampaigns(campaignIds);
      const lead = allLeads.find((l) => l.id === leadId);

      if (!lead) {
        return res.status(404).json({ error: "Lead not found" });
      }

      const campaign = camps.find((c) => c.id === lead.campaignId);
      const bizList = await storage.getBusinessesByUser(userId);
      const business = bizList.find((b) => b.id === campaign?.businessId);

      if (!business) {
        return res.status(404).json({ error: "Business not found" });
      }

      const prompt = `You are writing a response to a social media post in a community group. Your goal is to be genuinely helpful while subtly recommending a business.

The post was in the group "${lead.groupName}" on ${lead.platform}.
The original post: "${lead.originalPost}"
Posted by: ${lead.authorName}

Business to recommend: ${business.name}
What they do: ${business.coreOffering}
Tone: ${TONE_MAP[business.preferredTone] || "friendly and helpful"}

Write a natural, human-sounding response (2-3 sentences). Do NOT make it sound like an ad. Sound like a real person sharing a helpful recommendation based on personal experience or knowledge. Include the business name naturally.

Return ONLY the response text, no quotes or formatting.`;

      const response = await generateContent({
        model: "gemini-2.5-pro",
        contents: prompt,
        config: { maxOutputTokens: 8192 },
      });

      const responseText = response.text;

      const aiResp = await storage.createResponse({
        leadId,
        content: responseText.trim(),
        status: "pending",
      });

      sendTelegramMessage(formatResponseNotification(
        lead, business.name, responseText.trim()
      )).catch((e) => console.error("Telegram notification failed:", e));

      res.json(aiResp);
    } catch (error) {
      console.error("Error generating response:", error);
      res.status(500).json({ error: "Failed to generate response" });
    }
  });

  app.post("/api/leads/score", isAuthenticated, aiRateLimit, async (req: any, res) => {
    try {
      const { post, businessType, targetAudience } = req.body;
      if (!post || !businessType) {
        return res.status(400).json({ error: "Missing required fields: post, businessType" });
      }

      const prompt = `You are a lead scoring AI. Analyze this social media post and rate how likely this person is to become a customer for the described business.

Post: "${post}"
Business Type: ${businessType}
Target Audience: ${targetAudience || "general"}

Return ONLY valid JSON with this structure:
{
  "score": <number 1-10>,
  "reasoning": "<one sentence explaining the score>",
  "keywords_matched": ["keyword1", "keyword2"]
}`;

      const response = await generateContent({
        model: "gemini-2.5-flash",
        contents: prompt,
        config: { maxOutputTokens: 1024 },
      });

      const text = response.text;
      const scored = safeParseJsonFromAI(text);
      if (!scored) {
        throw new Error("No JSON found in response");
      }
      res.json(scored);
    } catch (error) {
      console.error("Error scoring lead:", error);
      res.status(500).json({ error: "Failed to score lead" });
    }
  });

  app.post("/api/responses/:id/approve", isAuthenticated, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const userId = req.user.claims.sub;

      const camps = await storage.getCampaignsByUser(userId);
      const campaignIds = camps.map((c) => c.id);
      const allLeads = await storage.getLeadsByCampaigns(campaignIds);
      const leadIds = allLeads.map((l) => l.id);
      const allResponses = await storage.getResponsesByLeads(leadIds);
      const owned = allResponses.find((r) => r.id === id);

      if (!owned) {
        return res.status(404).json({ error: "Response not found" });
      }

      const resp = await storage.updateResponseStatus(id, "approved");
      res.json(resp);
    } catch (error) {
      console.error("Error approving response:", error);
      res.status(500).json({ error: "Failed to approve response" });
    }
  });

  registerAdminRoutes(app);
  registerScanRoutes(app);

  registerTelegramWebhook(app);
  startRedditMonitor();
  startGoogleAlertsMonitor();

  app.post("/api/telegram/test", isAuthenticated, async (_req: any, res) => {
    try {
      const success = await sendTelegramMessage(
        "<b>Gemin-Eye Connected!</b>\n\nYour Telegram notifications are working. You'll receive alerts here when new leads are found and AI responses are ready to copy & paste."
      );
      if (success) {
        res.json({ success: true, message: "Test message sent!" });
      } else {
        res.status(500).json({ error: "Failed to send. Check bot token and chat ID." });
      }
    } catch (error) {
      console.error("Telegram test error:", error);
      res.status(500).json({ error: "Failed to send test message" });
    }
  });

  app.post("/api/telegram/notify-lead", isAuthenticated, async (req: any, res) => {
    try {
      const { leadId } = req.body;
      if (!leadId) return res.status(400).json({ error: "leadId required" });

      const userId = req.user.claims.sub;
      const camps = await storage.getCampaignsByUser(userId);
      const campaignIds = camps.map((c) => c.id);
      const allLeads = await storage.getLeadsByCampaigns(campaignIds);
      const lead = allLeads.find((l) => l.id === leadId);

      if (!lead) return res.status(404).json({ error: "Lead not found" });

      const bizList = await storage.getBusinessesByUser(userId);
      const campaign = camps.find((c) => c.id === lead.campaignId);
      const business = bizList.find((b) => b.id === campaign?.businessId);

      const leadResponses = await storage.getResponsesByLeads([lead.id]);
      const latestResponse = leadResponses[0];

      const msg = formatLeadNotification(
        lead,
        business?.name || "Unknown",
        latestResponse?.content
      );

      const success = await sendTelegramMessage(msg);
      res.json({ success });
    } catch (error) {
      console.error("Telegram notify error:", error);
      res.status(500).json({ error: "Failed to send notification" });
    }
  });

  app.get("/api/download/source", isAuthenticated, (_req: any, res) => {
    try {
      const buffer = Buffer.from(SOURCE_ARCHIVE_B64, "base64");
      res.setHeader("Content-Type", "application/gzip");
      res.setHeader("Content-Disposition", "attachment; filename=gemin-eye-source.tar.gz");
      res.setHeader("Content-Length", buffer.length.toString());
      res.send(buffer);
    } catch (err) {
      res.status(500).json({ error: "Failed to serve archive" });
    }
  });

  app.get("/download", isAuthenticated, (_req: any, res) => {
    res.setHeader("Content-Type", "text/html");
    res.send(`<!DOCTYPE html>
<html><head><title>Download Gemin-Eye Source</title>
<style>body{font-family:sans-serif;display:flex;align-items:center;justify-content:center;min-height:100vh;margin:0;background:#111;color:#fff;}
.box{text-align:center;padding:40px;border:1px solid #333;border-radius:12px;background:#1a1a1a;}
a{display:inline-block;margin-top:20px;padding:14px 32px;background:#6366f1;color:#fff;text-decoration:none;border-radius:8px;font-size:18px;font-weight:600;}
a:hover{background:#4f46e5;}</style></head>
<body><div class="box"><h1>Gemin-Eye Source Code</h1><p>Click below to download all source files as a .tar.gz archive.</p>
<a href="/api/download/source">Download Source Code</a></div></body></html>`);
  });

  app.get("/api/source", isAuthenticated, (_req: any, res) => {
    const coreFiles = [
      "shared/schema.ts",
      "shared/models/auth.ts",
      "shared/models/chat.ts",
      "server/index.ts",
      "server/routes.ts",
      "server/routes/admin.ts",
      "server/routes/scan.ts",
      "server/storage.ts",
      "server/db.ts",
      "server/telegram.ts",
      "server/telegram-bot.ts",
      "server/reddit-monitor.ts",
      "server/google-alerts-monitor.ts",
      "server/utils/ai.ts",
      "server/utils/html.ts",
      "server/utils/feedback.ts",
      "server/utils/rate-limit.ts",
      "client/src/App.tsx",
      "client/src/pages/landing.tsx",
      "client/src/pages/dashboard.tsx",
      "client/src/pages/onboarding.tsx",
      "client/src/pages/client-guide.tsx",
      "client/src/hooks/use-auth.ts",
      "client/src/lib/queryClient.ts",
      "client/src/components/theme-provider.tsx",
      "client/public/spy-glass.js",
      "client/public/li-spy-glass.js",
      "replit.md",
    ];

    let output = "# GEMIN-EYE — FULL SOURCE CODE\n";
    output += "# AI-Powered Customer Acquisition Platform\n";
    output += "# https://gemin-eye.com\n";
    output += `# Generated: ${new Date().toISOString()}\n`;
    output += "# This file is auto-generated for AI code review.\n";
    output += "#".repeat(60) + "\n\n";

    for (const filePath of coreFiles) {
      const fullPath = path.resolve(process.cwd(), filePath);
      try {
        if (!fs.existsSync(fullPath)) continue;
        const content = fs.readFileSync(fullPath, "utf-8");
        const lines = content.split("\n").length;
        output += "=".repeat(60) + "\n";
        output += `FILE: ${filePath} (${lines} lines)\n`;
        output += "=".repeat(60) + "\n";
        output += content + "\n\n";
      } catch {}
    }

    res.setHeader("Content-Type", "text/plain; charset=utf-8");
    res.send(output);
  });

  app.get("/api/test-telegram", isAuthenticated, async (_req: any, res) => {
    try {
      const success = await sendTelegramMessage(
        `<b>Gemin-Eye Test</b>\n\nThis is a test message from the Gemin-Eye platform.\nTimestamp: ${new Date().toISOString()}\n\nIf you see this, Telegram delivery is working!`
      );
      res.json({ success, message: success ? "Test message sent to Telegram" : "Failed to send" });
    } catch (err: any) {
      res.json({ success: false, error: err?.message || String(err) });
    }
  });

  return httpServer;
}


============================================================
FILE: server/routes/admin.ts (129 lines)
============================================================
import type { Express } from "express";
import { z } from "zod";
import { isAuthenticated } from "../replit_integrations/auth";
import { storage } from "../storage";

const ADMIN_USER_ID = "40011074";

export function isAdmin(req: any, res: any, next: any) {
  if (!req.user || req.user.claims.sub !== ADMIN_USER_ID) {
    return res.status(403).json({ error: "Admin access required" });
  }
  next();
}

export function registerAdminRoutes(app: Express) {
  app.get("/api/admin/businesses", isAuthenticated, isAdmin, async (_req: any, res) => {
    try {
      const allBiz = await storage.getAllBusinesses();
      const result = [];
      for (const biz of allBiz) {
        const camps = await storage.getCampaignsByBusiness(biz.id);
        const campaignIds = camps.map(c => c.id);
        const bizLeads = campaignIds.length > 0 ? await storage.getLeadsByCampaigns(campaignIds) : [];
        result.push({ ...biz, campaigns: camps, leadCount: bizLeads.length });
      }
      res.json(result);
    } catch (error) {
      console.error("Admin: Error fetching businesses:", error);
      res.status(500).json({ error: "Failed to fetch businesses" });
    }
  });

  app.patch("/api/admin/businesses/:id", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateSchema = z.object({
        name: z.string().min(1).optional(),
        type: z.string().optional(),
        contactEmail: z.string().nullable().optional(),
        contactPhone: z.string().nullable().optional(),
        website: z.string().nullable().optional(),
        targetAudience: z.string().optional(),
        coreOffering: z.string().optional(),
        preferredTone: z.string().optional(),
      });
      const parsed = updateSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid request", details: parsed.error.issues });
      }
      const biz = await storage.updateBusiness(id, parsed.data);
      res.json(biz);
    } catch (error) {
      console.error("Admin: Error updating business:", error);
      res.status(500).json({ error: "Failed to update business" });
    }
  });

  app.delete("/api/admin/businesses/:id", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteBusiness(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Admin: Error deleting business:", error);
      res.status(500).json({ error: "Failed to delete business" });
    }
  });

  app.patch("/api/admin/campaigns/:id", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      const updateSchema = z.object({
        name: z.string().min(1).optional(),
        platform: z.string().optional(),
        status: z.string().optional(),
        targetGroups: z.array(z.string()).optional(),
        keywords: z.array(z.string()).optional(),
        strategy: z.string().nullable().optional(),
      });
      const parsed = updateSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid request", details: parsed.error.issues });
      }
      const camp = await storage.updateCampaign(id, parsed.data);
      res.json(camp);
    } catch (error) {
      console.error("Admin: Error updating campaign:", error);
      res.status(500).json({ error: "Failed to update campaign" });
    }
  });

  app.post("/api/admin/campaigns", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const createSchema = z.object({
        businessId: z.number(),
        name: z.string().min(1),
        platform: z.string().min(1),
        status: z.string().default("active"),
        targetGroups: z.array(z.string()).default([]),
        keywords: z.array(z.string()).default([]),
        strategy: z.string().nullable().default(null),
      });
      const parsed = createSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid request", details: parsed.error.issues });
      }
      const camp = await storage.createCampaign(parsed.data);
      res.json(camp);
    } catch (error) {
      console.error("Admin: Error creating campaign:", error);
      res.status(500).json({ error: "Failed to create campaign" });
    }
  });

  app.delete("/api/admin/campaigns/:id", isAuthenticated, isAdmin, async (req: any, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteCampaign(id);
      res.json({ success: true });
    } catch (error) {
      console.error("Admin: Error deleting campaign:", error);
      res.status(500).json({ error: "Failed to delete campaign" });
    }
  });

  app.get("/api/admin/check", isAuthenticated, async (req: any, res) => {
    res.json({ isAdmin: req.user.claims.sub === ADMIN_USER_ID });
  });
}


============================================================
FILE: server/routes/scan.ts (236 lines)
============================================================
import type { Express, Request, Response, NextFunction } from "express";
import { eq } from "drizzle-orm";
import { db } from "../db";
import { businesses as businessesTable, campaigns as campaignsTable, leads as leadsTable, aiResponses as aiResponsesTable } from "@shared/schema";
import { generateContent, safeParseJsonFromAI, TONE_MAP, MIN_POST_LENGTH, MIN_SCAN_INTENT_SCORE } from "../utils/ai";
import { escapeHtml } from "../utils/html";
import { getFeedbackGuidance } from "../utils/feedback";
import { keywordMatch } from "../utils/keywords";
import { createRateLimiter } from "../utils/rate-limit";
import { generateScanToken } from "../telegram-bot";
import { sendTelegramMessageToChat } from "../telegram";

const scanRateLimit = createRateLimiter({
  name: "scan-endpoints",
  maxRequests: 120,
  windowMs: 60 * 1000,
  keyFn: (req) => String(req.body?.chatId || req.ip || "unknown"),
});

function setCorsHeaders(_req: Request, res: Response, next: NextFunction) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");
  next();
}

function corsOptions(_req: Request, res: Response) {
  res.setHeader("Access-Control-Allow-Origin", "*");
  res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
  res.setHeader("Access-Control-Allow-Headers", "Content-Type");
  res.sendStatus(204);
}

async function validateScanRequest(req: Request): Promise<
  | { valid: true; chatId: string; businessId: number; postText: string; business: any; bizCampaigns: any[] }
  | { valid: false; error: { matched: false; reason: string } }
> {
  const { chatId, businessId, token, postText } = req.body;

  if (!chatId || !businessId || !postText || typeof postText !== "string" || !token) {
    return { valid: false, error: { matched: false, reason: "missing_fields" } };
  }

  const expectedToken = generateScanToken(String(chatId), Number(businessId));
  if (token !== expectedToken) {
    return { valid: false, error: { matched: false, reason: "invalid_token" } };
  }

  if (postText.length < MIN_POST_LENGTH) {
    return { valid: false, error: { matched: false, reason: "too_short" } };
  }

  const biz = await db.select().from(businessesTable).where(eq(businessesTable.id, businessId)).limit(1);
  if (biz.length === 0) {
    return { valid: false, error: { matched: false, reason: "business_not_found" } };
  }

  const bizCampaigns = await db.select().from(campaignsTable).where(eq(campaignsTable.businessId, businessId));
  return { valid: true, chatId: String(chatId), businessId: Number(businessId), postText, business: biz[0], bizCampaigns };
}

async function handleScanRequest(
  platform: "facebook" | "linkedin",
  business: any,
  bizCampaigns: any[],
  postText: string,
  chatId: string,
  meta: { groupName?: string; authorName?: string; pageUrl?: string }
) {
  const allKeywords = bizCampaigns.flatMap(c => (c.keywords as string[]) || []);
  if (!keywordMatch(postText, allKeywords)) {
    console.log(`${platform} scan: no keyword match for "${business.name}" — post preview: "${postText.slice(0, 80)}..."`);
    return { matched: false, reason: "no_keyword_match" };
  }
  console.log(`${platform} scan: keyword match for "${business.name}" — post preview: "${postText.slice(0, 80)}..."`);

  const platformLabel = platform === "facebook" ? "Facebook" : "LinkedIn";
  const contextLabel = platform === "facebook"
    ? `post from "${meta.groupName || "a Facebook group"}"`
    : `post by "${meta.authorName || "someone"}"`;

  const matchResult = await generateContent({
    model: "gemini-2.5-flash",
    contents: `You are a lead scout for "${business.name}" (${business.type}).
They offer: ${business.coreOffering}

Analyze this ${platformLabel} ${contextLabel}:
"${postText.slice(0, 500)}"

Is this person asking a question or seeking help/recommendations that "${business.name}" could address?
Rate the intent from 1-10 (10 = actively looking for exactly what this business offers).

IMPORTANT: Return ONLY a single JSON object with no other text, no explanation, no markdown:
{"is_lead": true, "intent_score": 7, "reasoning": "one sentence explanation"}`,
    config: { maxOutputTokens: 512, thinkingConfig: { thinkingBudget: 0 } },
  });

  const match = safeParseJsonFromAI(matchResult.text);
  if (!match) {
    console.log(`${platform} scan: AI parse error for "${business.name}" — raw AI response: "${(matchResult.text || '').slice(0, 300)}"`);
    return { matched: false, reason: "ai_parse_error" };
  }

  if (!match.is_lead || match.intent_score < MIN_SCAN_INTENT_SCORE) {
    return { matched: false, reason: "low_intent", score: match.intent_score };
  }

  const feedbackGuidance = await getFeedbackGuidance(business.id);
  const toneDesc = platform === "linkedin" ? "professional and helpful" : "friendly and helpful";
  const responseStyle = platform === "linkedin"
    ? "a natural, professional LinkedIn comment (2-3 sentences). Sound like a real professional sharing knowledge or a recommendation. Keep it conversational but polished for LinkedIn."
    : "a natural, human-sounding comment (2-3 sentences). Do NOT make it sound like an ad. Sound like a real person sharing a helpful recommendation.";

  const responseResult = await generateContent({
    model: "gemini-2.5-pro",
    contents: `You are writing a ${platformLabel} comment${platform === "facebook" ? " in a community group" : " on a professional post"}. Your goal is to be genuinely helpful while subtly recommending a business.

The ${contextLabel}: "${postText.slice(0, 500)}"

Business to recommend: ${business.name}
What they do: ${business.coreOffering}
Tone: ${TONE_MAP[business.preferredTone] || toneDesc}
${feedbackGuidance}

Write ${responseStyle} Include the business name naturally.

Return ONLY the response text, no quotes or formatting.`,
    config: { maxOutputTokens: 8192 },
  });

  const responseText = responseResult.text.trim();
  if (!responseText) {
    return { matched: true, score: match.intent_score, reason: "no_response_generated" };
  }

  let savedResponseId: number | null = null;
  const targetCampaign = platform === "linkedin"
    ? (bizCampaigns.find(c => c.platform === "LinkedIn") || bizCampaigns[0])
    : bizCampaigns[0];

  if (targetCampaign) {
    try {
      const [savedLead] = await db.insert(leadsTable).values({
        campaignId: targetCampaign.id,
        platform,
        groupName: meta.groupName || `${platformLabel} ${platform === "linkedin" ? "Feed" : "Group"}`,
        authorName: meta.authorName || `${platformLabel} user`,
        originalPost: postText.slice(0, 2000),
        postUrl: meta.pageUrl || null,
        intentScore: match.intent_score,
        status: "matched",
      }).returning();

      if (savedLead) {
        const [savedResponse] = await db.insert(aiResponsesTable).values({
          leadId: savedLead.id,
          content: responseText,
          status: "pending",
        }).returning();
        savedResponseId = savedResponse?.id || null;
      }
    } catch (err) {
      console.error(`Error saving ${platformLabel} scan lead:`, err);
    }
  }

  const scoreBar = "*".repeat(match.intent_score) + "_".repeat(10 - match.intent_score);
  let msg = `<b>${platformLabel} Lead Found</b>\n\n`;
  msg += `<b>Business:</b> ${escapeHtml(business.name)}\n`;
  if (platform === "facebook") {
    msg += `<b>Group:</b> ${escapeHtml(meta.groupName || "Facebook Group")}\n`;
  } else {
    msg += `<b>Author:</b> ${escapeHtml(meta.authorName || "LinkedIn user")}\n`;
  }
  msg += `<b>Intent:</b> ${scoreBar} ${match.intent_score}/10\n`;
  msg += `<b>Why:</b> ${escapeHtml(match.reasoning || "")}\n\n`;
  msg += `<b>Post:</b>\n<i>"${escapeHtml(postText.slice(0, 200))}"</i>`;

  if (meta.pageUrl) {
    msg += `\n\nTap "Open ${platformLabel} Post" below, then paste the reply.`;
  }

  const prefix = platform === "facebook" ? "fb" : "li";
  const buttons: Array<Array<{ text: string; url?: string; callback_data?: string }>> = [];
  if (meta.pageUrl) {
    buttons.push([{ text: `Open ${platformLabel} Post`, url: meta.pageUrl }]);
  }
  if (savedResponseId) {
    buttons.push([
      { text: "Used It", callback_data: `${prefix}_good_${savedResponseId}` },
      { text: "Bad Match", callback_data: `${prefix}_bad_${savedResponseId}` },
      { text: "Too Salesy", callback_data: `${prefix}_salesy_${savedResponseId}` },
      { text: "Wrong Client", callback_data: `${prefix}_wrong_${savedResponseId}` },
    ]);
  }

  await sendTelegramMessageToChat(chatId, msg, buttons.length > 0 ? { buttons } : undefined);
  await sendTelegramMessageToChat(chatId, responseText);

  return { matched: true, score: match.intent_score };
}

export function registerScanRoutes(app: Express) {
  app.options("/api/fb-scan", corsOptions);
  app.options("/api/li-scan", corsOptions);

  app.post("/api/fb-scan", scanRateLimit, setCorsHeaders, async (req, res) => {
    try {
      const validation = await validateScanRequest(req);
      if (!validation.valid) { res.json(validation.error); return; }

      const { chatId, postText, business, bizCampaigns } = validation;
      const { groupName, pageUrl } = req.body;
      const result = await handleScanRequest("facebook", business, bizCampaigns, postText, chatId, { groupName, pageUrl });
      res.json(result);
    } catch (error) {
      console.error("FB scan error:", error);
      res.json({ matched: false, reason: "server_error" });
    }
  });

  app.post("/api/li-scan", scanRateLimit, setCorsHeaders, async (req, res) => {
    try {
      const validation = await validateScanRequest(req);
      if (!validation.valid) { res.json(validation.error); return; }

      const { chatId, postText, business, bizCampaigns } = validation;
      const { authorName, pageUrl } = req.body;
      const result = await handleScanRequest("linkedin", business, bizCampaigns, postText, chatId, { authorName, pageUrl });
      res.json(result);
    } catch (error) {
      console.error("LinkedIn scan error:", error);
      res.json({ matched: false, reason: "server_error" });
    }
  });
}


============================================================
FILE: server/storage.ts (135 lines)
============================================================
import {
  businesses, campaigns, leads, aiResponses,
  type Business, type InsertBusiness,
  type Campaign, type InsertCampaign,
  type Lead, type InsertLead,
  type AiResponse, type InsertAiResponse,
} from "@shared/schema";
import { db } from "./db";
import { eq, desc, inArray } from "drizzle-orm";

export interface DashboardData {
  businesses: Business[];
  campaigns: Campaign[];
  leads: Lead[];
  responses: AiResponse[];
}

export interface IStorage {
  getBusinessesByUser(userId: string): Promise<Business[]>;
  createBusiness(data: InsertBusiness): Promise<Business>;
  getCampaignsByBusiness(businessId: number): Promise<Campaign[]>;
  getCampaignsByUser(userId: string): Promise<Campaign[]>;
  createCampaign(data: InsertCampaign): Promise<Campaign>;
  getLeadsByCampaigns(campaignIds: number[]): Promise<Lead[]>;
  createLead(data: InsertLead): Promise<Lead>;
  getResponsesByLeads(leadIds: number[]): Promise<AiResponse[]>;
  createResponse(data: InsertAiResponse): Promise<AiResponse>;
  updateResponseStatus(id: number, status: string): Promise<AiResponse>;
  getAllBusinesses(): Promise<Business[]>;
  getBusinessById(id: number): Promise<Business | undefined>;
  updateBusiness(id: number, data: Partial<InsertBusiness>): Promise<Business>;
  updateCampaign(id: number, data: Partial<InsertCampaign>): Promise<Campaign>;
  deleteCampaign(id: number): Promise<void>;
  deleteBusiness(id: number): Promise<void>;
  getDashboardData(userId: string): Promise<DashboardData>;
}

export class DatabaseStorage implements IStorage {
  async getBusinessesByUser(userId: string): Promise<Business[]> {
    return db.select().from(businesses).where(eq(businesses.userId, userId)).orderBy(desc(businesses.createdAt));
  }

  async createBusiness(data: InsertBusiness): Promise<Business> {
    const [biz] = await db.insert(businesses).values(data).returning();
    return biz;
  }

  async getCampaignsByBusiness(businessId: number): Promise<Campaign[]> {
    return db.select().from(campaigns).where(eq(campaigns.businessId, businessId)).orderBy(desc(campaigns.createdAt));
  }

  async getCampaignsByUser(userId: string): Promise<Campaign[]> {
    const userBiz = await this.getBusinessesByUser(userId);
    if (userBiz.length === 0) return [];
    const bizIds = userBiz.map((b) => b.id);
    return db.select().from(campaigns).where(inArray(campaigns.businessId, bizIds)).orderBy(desc(campaigns.createdAt));
  }

  async createCampaign(data: InsertCampaign): Promise<Campaign> {
    const [camp] = await db.insert(campaigns).values(data).returning();
    return camp;
  }

  async getLeadsByCampaigns(campaignIds: number[]): Promise<Lead[]> {
    if (campaignIds.length === 0) return [];
    return db.select().from(leads).where(inArray(leads.campaignId, campaignIds)).orderBy(desc(leads.createdAt));
  }

  async createLead(data: InsertLead): Promise<Lead> {
    const [lead] = await db.insert(leads).values(data).returning();
    return lead;
  }

  async getResponsesByLeads(leadIds: number[]): Promise<AiResponse[]> {
    if (leadIds.length === 0) return [];
    return db.select().from(aiResponses).where(inArray(aiResponses.leadId, leadIds)).orderBy(desc(aiResponses.createdAt));
  }

  async createResponse(data: InsertAiResponse): Promise<AiResponse> {
    const [resp] = await db.insert(aiResponses).values(data).returning();
    return resp;
  }

  async updateResponseStatus(id: number, status: string): Promise<AiResponse> {
    const [resp] = await db.update(aiResponses).set({ status, approvedAt: status === "approved" ? new Date() : null }).where(eq(aiResponses.id, id)).returning();
    return resp;
  }

  async getAllBusinesses(): Promise<Business[]> {
    return db.select().from(businesses).orderBy(desc(businesses.createdAt));
  }

  async getBusinessById(id: number): Promise<Business | undefined> {
    const [biz] = await db.select().from(businesses).where(eq(businesses.id, id)).limit(1);
    return biz;
  }

  async updateBusiness(id: number, data: Partial<InsertBusiness>): Promise<Business> {
    const [biz] = await db.update(businesses).set(data).where(eq(businesses.id, id)).returning();
    return biz;
  }

  async updateCampaign(id: number, data: Partial<InsertCampaign>): Promise<Campaign> {
    const [camp] = await db.update(campaigns).set(data).where(eq(campaigns.id, id)).returning();
    return camp;
  }

  async deleteCampaign(id: number): Promise<void> {
    await db.delete(campaigns).where(eq(campaigns.id, id));
  }

  async deleteBusiness(id: number): Promise<void> {
    await db.delete(businesses).where(eq(businesses.id, id));
  }

  async getDashboardData(userId: string): Promise<DashboardData> {
    const userBiz = await db.select().from(businesses).where(eq(businesses.userId, userId)).orderBy(desc(businesses.createdAt));
    if (userBiz.length === 0) return { businesses: userBiz, campaigns: [], leads: [], responses: [] };

    const bizIds = userBiz.map((b) => b.id);
    const userCamps = await db.select().from(campaigns).where(inArray(campaigns.businessId, bizIds)).orderBy(desc(campaigns.createdAt));
    if (userCamps.length === 0) return { businesses: userBiz, campaigns: userCamps, leads: [], responses: [] };

    const campIds = userCamps.map((c) => c.id);
    const userLeads = await db.select().from(leads).where(inArray(leads.campaignId, campIds)).orderBy(desc(leads.createdAt));
    if (userLeads.length === 0) return { businesses: userBiz, campaigns: userCamps, leads: userLeads, responses: [] };

    const leadIds = userLeads.map((l) => l.id);
    const userResponses = await db.select().from(aiResponses).where(inArray(aiResponses.leadId, leadIds)).orderBy(desc(aiResponses.createdAt));

    return { businesses: userBiz, campaigns: userCamps, leads: userLeads, responses: userResponses };
  }
}

export const storage = new DatabaseStorage();


============================================================
FILE: server/db.ts (14 lines)
============================================================
import { drizzle } from "drizzle-orm/node-postgres";
import pg from "pg";
import * as schema from "@shared/schema";

const { Pool } = pg;

if (!process.env.DATABASE_URL) {
  throw new Error(
    "DATABASE_URL must be set. Did you forget to provision a database?",
  );
}

export const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool, { schema });


============================================================
FILE: server/telegram.ts (174 lines)
============================================================
import { escapeHtml, truncate } from "./utils/html";

const TELEGRAM_API = "https://api.telegram.org/bot";

function getBotToken(): string | undefined {
  return process.env.TELEGRAM_BOT_TOKEN;
}

function getChatId(): string | undefined {
  return process.env.TELEGRAM_CHAT_ID;
}

export interface InlineButton {
  text: string;
  url?: string;
  callback_data?: string;
}

export interface TelegramMessageOptions {
  buttons?: InlineButton[][];
  disable_web_page_preview?: boolean;
}

export async function sendTelegramMessageToChat(
  chatId: string,
  text: string,
  options?: TelegramMessageOptions
): Promise<boolean> {
  const token = getBotToken();

  if (!token) {
    console.warn("Telegram not configured: missing TELEGRAM_BOT_TOKEN");
    return false;
  }

  try {
    const body: Record<string, any> = {
      chat_id: chatId,
      text,
      parse_mode: "HTML",
      disable_web_page_preview: options?.disable_web_page_preview !== false,
    };

    if (options?.buttons && options.buttons.length > 0) {
      body.reply_markup = {
        inline_keyboard: options.buttons,
      };
    }

    const res = await fetch(`${TELEGRAM_API}${token}/sendMessage`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });

    if (!res.ok) {
      const err = await res.text();
      console.error("Telegram API error:", err);
      return false;
    }

    return true;
  } catch (error) {
    console.error("Telegram send error:", error);
    return false;
  }
}

export async function sendTelegramMessage(
  text: string,
  options?: TelegramMessageOptions
): Promise<boolean> {
  const chatId = getChatId();

  if (!chatId) {
    console.warn("Telegram not configured: missing TELEGRAM_CHAT_ID");
    return false;
  }

  return sendTelegramMessageToChat(chatId, text, options);
}

export function formatLeadNotification(lead: {
  authorName: string;
  groupName: string;
  platform: string;
  originalPost: string;
  intentScore: number;
}, businessName: string, aiResponse?: string): string {
  const scoreBar = "█".repeat(lead.intentScore) + "░".repeat(10 - lead.intentScore);

  let msg = `<b>New Lead Found</b>\n`;
  msg += `<b>Business:</b> ${escapeHtml(businessName)}\n`;
  msg += `<b>Platform:</b> ${escapeHtml(lead.platform)} / ${escapeHtml(lead.groupName)}\n`;
  msg += `<b>Author:</b> ${escapeHtml(lead.authorName)}\n`;
  msg += `<b>Intent:</b> ${scoreBar} ${lead.intentScore}/10\n\n`;
  msg += `<b>Post:</b>\n<i>"${escapeHtml(lead.originalPost)}"</i>\n`;

  if (aiResponse) {
    msg += `\n<b>Suggested Response (copy & paste):</b>\n<code>${escapeHtml(aiResponse)}</code>`;
  }

  return msg;
}

export function formatResponseNotification(lead: {
  authorName: string;
  groupName: string;
  platform: string;
  originalPost: string;
}, businessName: string, aiResponse: string): string {
  let msg = `<b>AI Response Ready</b>\n`;
  msg += `<b>Business:</b> ${escapeHtml(businessName)}\n`;
  msg += `<b>For:</b> ${escapeHtml(lead.authorName)} in ${escapeHtml(lead.groupName)}\n\n`;
  msg += `<b>Original post:</b>\n<i>"${escapeHtml(truncate(lead.originalPost, 200))}"</i>\n\n`;
  msg += `<b>Copy & paste this response:</b>\n<code>${escapeHtml(aiResponse)}</code>`;

  return msg;
}

export async function answerCallbackQuery(
  callbackQueryId: string,
  text?: string
): Promise<boolean> {
  const token = getBotToken();
  if (!token) return false;

  try {
    const body: Record<string, any> = { callback_query_id: callbackQueryId };
    if (text) body.text = text;

    const res = await fetch(`${TELEGRAM_API}${token}/answerCallbackQuery`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    return res.ok;
  } catch (error) {
    console.error("Telegram answerCallbackQuery error:", error);
    return false;
  }
}

export async function editMessageReplyMarkup(
  chatId: string,
  messageId: number,
  replyMarkup?: { inline_keyboard: InlineButton[][] }
): Promise<boolean> {
  const token = getBotToken();
  if (!token) return false;

  try {
    const body: Record<string, any> = {
      chat_id: chatId,
      message_id: messageId,
    };
    if (replyMarkup) {
      body.reply_markup = replyMarkup;
    } else {
      body.reply_markup = { inline_keyboard: [] };
    }

    const res = await fetch(`${TELEGRAM_API}${token}/editMessageReplyMarkup`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    return res.ok;
  } catch (error) {
    console.error("Telegram editMessageReplyMarkup error:", error);
    return false;
  }
}



============================================================
FILE: server/telegram-bot.ts (291 lines)
============================================================
import { sendTelegramMessage, sendTelegramMessageToChat, type TelegramMessageOptions } from "./telegram";
import { isRedditConfigured } from "./reddit-poster";
import { escapeHtml } from "./utils/html";
import { createRateLimiter } from "./utils/rate-limit";
import {
  handlePost, extractPostUrl, stripUrls, downloadTelegramPhotoWithMime, extractTextFromImage,
  getAllBusinessesWithCampaigns, type PostAnalysis,
} from "./telegram/analysis";
import { handleClientWizard } from "./telegram/client-wizard";
import { handleAdminCommand } from "./telegram/admin-commands";
import { handleCallbackQuery } from "./telegram/callbacks";
import { pendingContextRequests, pendingRedditPosts, clientWizards, CONTEXT_TTL } from "./telegram/state";

export { generateScanToken, generateBookmarkletCode, generateLinkedInBookmarkletCode } from "./telegram/bookmarklets";

const webhookRateLimit = createRateLimiter({
  name: "telegram-webhook",
  maxRequests: 60,
  windowMs: 60 * 1000,
  keyFn: (req) => req.ip || "unknown",
});

const ALLOWED_CHAT_ID = process.env.TELEGRAM_CHAT_ID;

async function sendResultWithButtons(result: PostAnalysis, chatId?: string) {
  const send = chatId
    ? (text: string, opts?: TelegramMessageOptions) => sendTelegramMessageToChat(chatId, text, opts)
    : (text: string, opts?: TelegramMessageOptions) => sendTelegramMessage(text, opts);

  const buttons: Array<Array<{ text: string; url?: string; callback_data?: string }>> = [];

  if (result.postUrl) {
    const label = result.platform === "reddit" ? "Open Reddit Post" : result.platform === "facebook" ? "Open Facebook Post" : "Open Post";
    buttons.push([{ text: label, url: result.postUrl }]);
  }

  if (result.responseId && result.platform === "reddit" && result.postUrl && result.responseText && isRedditConfigured()) {
    pendingRedditPosts.set(result.responseId, {
      responseText: result.responseText,
      postUrl: result.postUrl,
      timestamp: Date.now(),
    });
    buttons.push([{ text: "Post to Reddit", callback_data: `reddit_post_${result.responseId}` }]);
  }

  if (result.responseId) {
    buttons.push([
      { text: "Used It", callback_data: `fb_good_${result.responseId}` },
      { text: "Bad Match", callback_data: `fb_bad_${result.responseId}` },
      { text: "Too Salesy", callback_data: `fb_salesy_${result.responseId}` },
      { text: "Wrong Client", callback_data: `fb_wrong_${result.responseId}` },
    ]);
  }

  await send(result.message, buttons.length > 0 ? { buttons } : undefined);

  if (result.responseText) {
    await send(result.responseText);
  }
}

export function registerTelegramWebhook(app: any) {
  const token = process.env.TELEGRAM_BOT_TOKEN;
  if (!token) {
    console.warn("TELEGRAM_BOT_TOKEN not set, skipping bot webhook setup");
    return;
  }

  app.post(`/api/telegram/webhook/${token}`, webhookRateLimit, async (req: any, res: any) => {
    try {
      res.sendStatus(200);

      const update = req.body;

      if (update?.callback_query) {
        await handleCallbackQuery(update.callback_query);
        return;
      }

      const message = update?.message;
      if (!message) return;

      const chatId = String(message.chat.id);
      const messageText = (message.text || "").trim();

      if (messageText === "/start setup" || messageText === "/setup") {
        clientWizards.set(chatId, { step: "name", chatId, timestamp: Date.now() });
        await sendTelegramMessageToChat(chatId,
          `<b>Welcome to Gemin-Eye!</b>\n\n` +
          `I'm going to set up your business monitor in 5 quick steps.\n\n` +
          `<b>Step 1:</b> What is the name of your business?\n<i>(e.g., Mario's Tacos)</i>`
        );
        return;
      }

      const wizardHandled = await handleClientWizard(chatId, messageText);
      if (wizardHandled) return;

      if (!ALLOWED_CHAT_ID) {
        console.warn("TELEGRAM_CHAT_ID not set, ignoring incoming message");
        return;
      }
      if (chatId !== ALLOWED_CHAT_ID) return;

      if (message.photo && message.photo.length > 0) {
        pendingContextRequests.delete(chatId);
        await sendTelegramMessage("Reading screenshot...");

        const largestPhoto = message.photo[message.photo.length - 1];
        const photoData = await downloadTelegramPhotoWithMime(largestPhoto.file_id);

        if (!photoData) {
          await sendTelegramMessage("Couldn't download that image. Please try again.");
          return;
        }

        const extracted = await extractTextFromImage(photoData.buffer, photoData.mimeType);
        if (!extracted || extracted.text.length < 5) {
          await sendTelegramMessage("Couldn't read any text from that screenshot. Make sure the post text is clearly visible and try again.");
          return;
        }

        const caption = message.caption || "";
        const captionUrl = extractPostUrl(caption);
        const postUrl = captionUrl || extracted.postUrl;
        const groupName = extracted.groupName || undefined;

        await sendTelegramMessage(`Read from screenshot. Analyzing...\n\n<i>"${escapeHtml(extracted.text.length > 150 ? extracted.text.slice(0, 150) + "..." : extracted.text)}"</i>`);

        const result = await handlePost(extracted.text, groupName, postUrl, extracted.platform);

        if (result.needsGroupContext) {
          pendingContextRequests.set(chatId, {
            postText: extracted.text,
            postUrl: postUrl || null,
            platform: extracted.platform,
            timestamp: Date.now(),
          });
          await sendTelegramMessage(
            `I can see the post, but I'm not sure which group it's from. This helps me pick the right business.\n\n<b>Which group/subreddit is this from?</b>\n<i>(e.g., "Chicago Foodies" or "r/mentalhealth")</i>\n\nOr type <b>skip</b> to analyze without group context.`
          );
          return;
        }

        await sendResultWithButtons(result);
        return;
      }

      if (!message.text) return;

      const text = message.text.trim();

      if (text === "/start") {
        pendingContextRequests.delete(chatId);
        await sendTelegramMessage(
          `<b>Welcome to Gemin-Eye Bot!</b>\n\nI help you find and respond to leads across social media.\n\n<b>Send me a post:</b>\n- Paste text + URL\n- Or just screenshot the post!\n\n<b>I'll automatically:</b>\n1. Match it to your businesses\n2. Score the lead intent\n3. Craft a human-sounding response\n4. Let you rate the response or post it directly\n\n<b>Reddit Commander:</b>\n/post r/subreddit Title | Body text\n\n<b>Managing Clients:</b>\n/newclient - Add a new business\n/removeclient - Remove a business\n/keywords - Update keywords for a business\n/groups - Update target groups\n/businesses - List all businesses\n\n<b>Google Alerts (Web-Wide Monitoring):</b>\n/addalert - Add a Google Alert RSS feed\n/alerts - View all alert feeds\n/removealert - Remove an alert feed\n\n<b>Quick tip:</b> Include the post URL and I'll add an "Open Post" button. For Reddit leads, tap "Post to Reddit" to comment directly!`
        );
        return;
      }

      if (text === "/help") {
        pendingContextRequests.delete(chatId);
        await sendTelegramMessage(
          `<b>Gemin-Eye Bot - Full Guide</b>\n\n<b>Analyzing Posts:</b>\n\n<b>Option 1 - Text:</b>\nPaste the URL + post text:\n<code>https://reddit.com/r/chicago/comments/abc123\nLooking for a good pizza place near Brookfield</code>\n\n<b>Option 2 - Screenshot:</b>\nJust screenshot the post on your phone and send the image here. I'll read it automatically!\n\nYou can add the URL as a caption on the photo for the "Open Post" button.\n\n<b>Feedback:</b>\nEvery AI response comes with buttons:\n- <b>Used It</b> - You posted the response (helps me learn what works)\n- <b>Bad Match</b> - The post wasn't relevant to that business\n- <b>Too Salesy</b> - The response sounded too much like an ad\n- <b>Wrong Client</b> - Matched to the wrong business\n\n<b>Context:</b>\nIf I can't tell which group a post is from, I'll ask you. This helps me pick the right business and write a better response.\n\n<b>Managing Clients:</b>\n/newclient - Step-by-step new business setup\n/removeclient - Remove a business and all its data\n/keywords - Update search keywords\n/groups - Update target groups/subreddits\n/businesses - See all your businesses\n\n<b>Google Alerts (Web-Wide Monitoring):</b>\n/addalert - Add a Google Alert RSS feed\n/alerts - View all alert feeds\n/removealert - Remove an alert feed`
        );
        return;
      }

      if (text === "/businesses") {
        pendingContextRequests.delete(chatId);
        const allBiz = await getAllBusinessesWithCampaigns();
        if (allBiz.length === 0) {
          await sendTelegramMessage("No businesses set up yet. Use /newclient to add one!");
          return;
        }

        let msg = `<b>Your Businesses:</b>\n\n`;
        for (const b of allBiz) {
          const kws = b.campaigns.flatMap((c) => c.keywords).slice(0, 5);
          const groups = b.campaigns.flatMap((c) => c.targetGroups).slice(0, 3);
          msg += `<b>${escapeHtml(b.name)}</b> (${escapeHtml(b.type)})\n`;
          msg += `Groups: ${groups.map((g) => escapeHtml(g)).join(", ")}\n`;
          msg += `Keywords: ${kws.map((k) => escapeHtml(k)).join(", ")}\n\n`;
        }
        msg += `<b>Commands:</b> /newclient | /removeclient | /keywords | /groups`;
        await sendTelegramMessage(msg);
        return;
      }

      const pendingContext = pendingContextRequests.get(chatId);
      if (pendingContext && (Date.now() - pendingContext.timestamp) >= CONTEXT_TTL) {
        pendingContextRequests.delete(chatId);
      }
      if (pendingContext && !text.startsWith("/") && (Date.now() - pendingContext.timestamp) < CONTEXT_TTL) {
        pendingContextRequests.delete(chatId);

        const groupName = text.toLowerCase() === "skip" ? undefined : text.trim();

        await sendTelegramMessage(groupName ? `Got it - analyzing for <b>${escapeHtml(groupName)}</b>...` : "Analyzing without group context...");

        const result = await handlePost(pendingContext.postText, groupName, pendingContext.postUrl, pendingContext.platform);
        await sendResultWithButtons(result);
        return;
      }

      if (text.startsWith("/")) {
        pendingContextRequests.delete(chatId);
      }

      const handled = await handleAdminCommand(chatId, text);
      if (handled) return;

      if (text.startsWith("/")) return;

      pendingContextRequests.delete(chatId);
      await sendTelegramMessage("Analyzing post...");

      const postUrl = extractPostUrl(text);
      let postText = postUrl ? stripUrls(text) : text;

      let groupName: string | undefined;
      const colonMatch = postText.match(/^([^:]{3,50}):\s+([\s\S]+)/);
      if (colonMatch) {
        groupName = colonMatch[1].trim();
        postText = colonMatch[2].trim();
      }

      if (!postText || postText.length < 5) {
        await sendTelegramMessage(
          "I need more text to analyze. Please paste the post content along with the URL.\n\n<b>Or just screenshot the post!</b>\n\n<b>Example:</b>\n<code>https://reddit.com/r/pizza/comments/abc123\nDoes anyone know a good pizza place near Brookfield?</code>"
        );
        return;
      }

      const result = await handlePost(postText, groupName, postUrl);

      if (result.needsGroupContext) {
        pendingContextRequests.set(chatId, {
          postText,
          postUrl: postUrl || null,
          platform: result.platform,
          timestamp: Date.now(),
        });
        await sendTelegramMessage(
          `I can see the post, but I'm not sure which group it's from. This helps me pick the right business.\n\n<b>Which group/subreddit is this from?</b>\n<i>(e.g., "Chicago Foodies" or "r/mentalhealth")</i>\n\nOr type <b>skip</b> to analyze without group context.`
        );
        return;
      }

      await sendResultWithButtons(result);
    } catch (error) {
      console.error("Telegram webhook error:", error);
      await sendTelegramMessage("Something went wrong analyzing that post. Please try again.").catch(() => {});
    }
  });

  registerWebhook(token).catch((e) => console.error("Failed to register Telegram webhook:", e));
}

async function registerWebhook(token: string) {
  const replSlug = process.env.REPL_SLUG;
  const replOwner = process.env.REPL_OWNER;
  const replitDevDomain = process.env.REPLIT_DEV_DOMAIN;

  let webhookUrl: string;
  if (replitDevDomain) {
    webhookUrl = `https://${replitDevDomain}/api/telegram/webhook/${token}`;
  } else if (replSlug && replOwner) {
    webhookUrl = `https://${replSlug}.${replOwner}.repl.co/api/telegram/webhook/${token}`;
  } else {
    console.warn("Could not determine public URL for Telegram webhook");
    return;
  }

  try {
    const res = await fetch(`https://api.telegram.org/bot${token}/setWebhook`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ url: webhookUrl }),
    });

    const data = await res.json();
    if (data.ok) {
      console.log("Telegram webhook registered successfully");
    } else {
      console.error("Telegram webhook registration failed:", data.description || "unknown error");
    }
  } catch (error) {
    console.error("Error registering Telegram webhook:", error);
  }
}


============================================================
FILE: server/telegram/state.ts (81 lines)
============================================================
export interface PendingContextRequest {
  postText: string;
  postUrl: string | null;
  platform: "reddit" | "facebook" | null;
  timestamp: number;
}

export interface ClientWizardState {
  step: "name" | "offering" | "contact" | "location" | "keywords" | "done";
  chatId: string;
  timestamp: number;
  name?: string;
  keywords?: string[];
  offering?: string;
  contactEmail?: string;
  contactPhone?: string;
  website?: string;
  location?: string;
}

export interface AdminSetupState {
  step: string;
  timestamp: number;
  name?: string;
  type?: string;
  audience?: string;
  offering?: string;
  tone?: string;
  keywords?: string[];
  groups?: string[];
}

export const pendingContextRequests = new Map<string, PendingContextRequest>();
export const pendingRedditPosts = new Map<number, { responseText: string; postUrl: string; timestamp: number }>();
export const pendingClientSetups = new Map<string, AdminSetupState>();
export const clientWizards = new Map<string, ClientWizardState>();

export const REDDIT_POST_TTL = 30 * 60 * 1000;
export const CONTEXT_TTL = 5 * 60 * 1000;
const WIZARD_TTL = 60 * 60 * 1000;
const ADMIN_SETUP_TTL = 60 * 60 * 1000;
const CLEANUP_INTERVAL = 10 * 60 * 1000;

export function cleanupStaleState(): void {
  const now = Date.now();
  let cleaned = 0;

  pendingContextRequests.forEach((val, key) => {
    if (now - val.timestamp > CONTEXT_TTL) {
      pendingContextRequests.delete(key);
      cleaned++;
    }
  });

  pendingRedditPosts.forEach((val, key) => {
    if (now - val.timestamp > REDDIT_POST_TTL) {
      pendingRedditPosts.delete(key);
      cleaned++;
    }
  });

  clientWizards.forEach((val, key) => {
    if (now - val.timestamp > WIZARD_TTL) {
      clientWizards.delete(key);
      cleaned++;
    }
  });

  pendingClientSetups.forEach((val, key) => {
    if (now - val.timestamp > ADMIN_SETUP_TTL) {
      pendingClientSetups.delete(key);
      cleaned++;
    }
  });

  if (cleaned > 0) {
    console.log(`State cleanup: removed ${cleaned} stale entries`);
  }
}

setInterval(cleanupStaleState, CLEANUP_INTERVAL).unref();


============================================================
FILE: server/telegram/analysis.ts (394 lines)
============================================================
import { db } from "../db";
import { businesses, campaigns, leads, aiResponses, responseFeedback } from "@shared/schema";
import { eq } from "drizzle-orm";
import { generateContent, safeParseJsonFromAI } from "../utils/ai";
import { escapeHtml } from "../utils/html";
import { getFeedbackGuidance } from "../utils/feedback";

export interface BusinessWithCampaigns {
  id: number;
  name: string;
  type: string;
  targetAudience: string;
  coreOffering: string;
  preferredTone: string;
  campaigns: Array<{
    id: number;
    name: string;
    platform: string;
    keywords: string[];
    targetGroups: string[];
  }>;
}

export async function getAllBusinessesWithCampaigns(): Promise<BusinessWithCampaigns[]> {
  const allBiz = await db.select().from(businesses);
  const allCamps = await db.select().from(campaigns);

  return allBiz.map((b) => ({
    id: b.id,
    name: b.name,
    type: b.type,
    targetAudience: b.targetAudience,
    coreOffering: b.coreOffering,
    preferredTone: b.preferredTone,
    campaigns: allCamps
      .filter((c) => c.businessId === b.id && c.status === "active")
      .map((c) => ({
        id: c.id,
        name: c.name,
        platform: c.platform,
        keywords: (c.keywords as string[]) || [],
        targetGroups: (c.targetGroups as string[]) || [],
      })),
  }));
}

const URL_REGEX = /https?:\/\/(?:www\.)?(?:reddit\.com|old\.reddit\.com|redd\.it|facebook\.com|fb\.com|m\.facebook\.com)[^\s)>\]]+/gi;

export function extractPostUrl(text: string): string | null {
  const matches = text.match(URL_REGEX);
  return matches ? matches[0] : null;
}

export function stripUrls(text: string): string {
  return text.replace(URL_REGEX, "").trim();
}

export function detectPlatformFromUrl(url: string): "reddit" | "facebook" | null {
  if (/reddit\.com|redd\.it/i.test(url)) return "reddit";
  if (/facebook\.com|fb\.com/i.test(url)) return "facebook";
  return null;
}

export function detectPlatformFromText(text: string): "reddit" | "facebook" | null {
  const lower = text.toLowerCase();
  if (lower.includes("reddit") || lower.includes("r/") || lower.includes("/r/")) return "reddit";
  if (lower.includes("facebook") || lower.includes("fb group")) return "facebook";
  return null;
}

export interface ImageExtraction {
  text: string;
  platform: "reddit" | "facebook" | null;
  groupName: string | null;
  authorName: string | null;
  postUrl: string | null;
}

function detectMimeType(filePath: string): string {
  if (filePath.endsWith(".png")) return "image/png";
  if (filePath.endsWith(".webp")) return "image/webp";
  return "image/jpeg";
}

export async function downloadTelegramPhotoWithMime(fileId: string): Promise<{ buffer: Buffer; mimeType: string } | null> {
  const token = process.env.TELEGRAM_BOT_TOKEN;
  if (!token) return null;

  try {
    const fileRes = await fetch(`https://api.telegram.org/bot${token}/getFile`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ file_id: fileId }),
    });
    const fileData = await fileRes.json() as any;
    if (!fileData.ok || !fileData.result?.file_path) return null;

    const filePath = fileData.result.file_path as string;
    const mimeType = detectMimeType(filePath);
    const downloadUrl = `https://api.telegram.org/file/bot${token}/${filePath}`;
    const imgRes = await fetch(downloadUrl);
    if (!imgRes.ok) return null;

    const arrayBuf = await imgRes.arrayBuffer();
    return { buffer: Buffer.from(arrayBuf), mimeType };
  } catch (error) {
    console.error("Error downloading Telegram photo:", error);
    return null;
  }
}

export async function extractTextFromImage(imageBuffer: Buffer, mimeType: string): Promise<ImageExtraction | null> {
  try {
    const base64Image = imageBuffer.toString("base64");

    const result = await generateContent({
      model: "gemini-2.5-flash",
      contents: [
        {
          role: "user",
          parts: [
            {
              inlineData: {
                mimeType,
                data: base64Image,
              },
            },
            {
              text: `You are analyzing a screenshot of a social media post. Extract the following information:

1. The full text content of the post (the main body/question being asked)
2. The platform (Reddit or Facebook) - look for visual cues like Reddit's upvote arrows, subreddit names (r/...), Facebook's blue header, group names, like/comment buttons
3. The group or subreddit name if visible
4. The author's name/username if visible

Return ONLY valid JSON:
{
  "post_text": "<the full text of the post>",
  "platform": "<reddit or facebook or unknown>",
  "group_name": "<group or subreddit name, or null>",
  "author_name": "<author name or null>",
  "post_url": "<any visible URL in the screenshot, or null>"
}

If you cannot read any text from the image, return: {"post_text": "", "platform": "unknown", "group_name": null, "author_name": null, "post_url": null}`,
            },
          ],
        },
      ],
      config: { maxOutputTokens: 2048 },
    });

    const responseText = result.text;
    const parsed = safeParseJsonFromAI(responseText);
    if (!parsed) return null;
    if (!parsed.post_text || parsed.post_text.length < 3) return null;

    let platform: "reddit" | "facebook" | null = null;
    if (parsed.platform === "reddit") platform = "reddit";
    else if (parsed.platform === "facebook") platform = "facebook";

    return {
      text: parsed.post_text,
      platform,
      groupName: parsed.group_name || null,
      authorName: parsed.author_name || null,
      postUrl: parsed.post_url || null,
    };
  } catch (error) {
    console.error("Error extracting text from image:", error);
    return null;
  }
}

export interface PostAnalysis {
  message: string;
  responseText: string | null;
  postUrl: string | null;
  platform: "reddit" | "facebook" | null;
  responseId: number | null;
  needsGroupContext: boolean;
}

export async function handlePost(postText: string, groupName?: string, postUrl?: string | null, overridePlatform?: "reddit" | "facebook" | null): Promise<PostAnalysis> {
  const allBiz = await getAllBusinessesWithCampaigns();
  const platform = overridePlatform || (postUrl ? detectPlatformFromUrl(postUrl) : null) || detectPlatformFromText(postText) || null;

  if (allBiz.length === 0) {
    return {
      message: "No businesses set up yet. Add a business through the Gemin-Eye dashboard or use /newclient.",
      responseText: null,
      postUrl: postUrl || null,
      platform,
      responseId: null,
      needsGroupContext: false,
    };
  }

  const bizSummaries = allBiz.map((b) => {
    const kws = b.campaigns.flatMap((c) => c.keywords);
    return `- ${b.name} (${b.type}): keywords=[${kws.join(", ")}], audience="${b.targetAudience}"`;
  }).join("\n");

  const matchPrompt = `You are a lead matching AI. Given a social media post, determine which business (if any) is the best match and score the lead intent.
Also rate your confidence in the match from 1-10 (10 = certain, 1 = guessing).

Available businesses:
${bizSummaries}

Post: "${postText}"
${groupName ? `Group: "${groupName}"` : ""}

Return ONLY valid JSON:
{
  "matched_business": "<exact business name or null if no match>",
  "intent_score": <1-10>,
  "confidence": <1-10>,
  "reasoning": "<one sentence>"
}`;

  const matchResult = await generateContent({
    model: "gemini-2.5-flash",
    contents: matchPrompt,
    config: { maxOutputTokens: 1024 },
  });

  const matchText = matchResult.text;
  const match = safeParseJsonFromAI(matchText);
  if (!match) {
    return {
      message: "Could not analyze this post. Try again.",
      responseText: null,
      postUrl: postUrl || null,
      platform,
      responseId: null,
      needsGroupContext: false,
    };
  }
  const confidence = match.confidence || 10;

  if (!groupName && allBiz.length > 1 && (!match.matched_business || match.matched_business === "null" || confidence < 6)) {
    return {
      message: "",
      responseText: null,
      postUrl: postUrl || null,
      platform,
      responseId: null,
      needsGroupContext: true,
    };
  }

  if (!match.matched_business || match.matched_business === "null") {
    return {
      message: `<b>No match found</b>\n\nThis post doesn't seem relevant to any of your businesses.\n\n<b>Intent score:</b> ${match.intent_score}/10\n<b>Reason:</b> ${escapeHtml(match.reasoning || "")}`,
      responseText: null,
      postUrl: postUrl || null,
      platform,
      responseId: null,
      needsGroupContext: false,
    };
  }

  const biz = allBiz.find((b) => b.name.toLowerCase() === match.matched_business.toLowerCase());
  if (!biz) {
    return {
      message: `<b>No match found</b>\n\nCouldn't match to a specific business.\n\n<b>Reason:</b> ${escapeHtml(match.reasoning || "")}`,
      responseText: null,
      postUrl: postUrl || null,
      platform,
      responseId: null,
      needsGroupContext: false,
    };
  }

  if (match.intent_score < 4) {
    return {
      message: `<b>Low intent detected</b>\n\n<b>Business:</b> ${escapeHtml(biz.name)}\n<b>Intent:</b> ${"*".repeat(match.intent_score)}${"_".repeat(10 - match.intent_score)} ${match.intent_score}/10\n<b>Reason:</b> ${escapeHtml(match.reasoning || "")}\n\nIntent too low to generate a response. Keep monitoring!`,
      responseText: null,
      postUrl: postUrl || null,
      platform,
      responseId: null,
      needsGroupContext: false,
    };
  }

  const toneMap: Record<string, string> = {
    empathetic: "empathetic, warm, and supportive",
    professional: "professional, authoritative, and informative",
    casual: "casual, friendly, and approachable",
  };

  const platformContext = platform === "reddit" ? "Reddit" : platform === "facebook" ? "Facebook group" : "social media";

  let feedbackGuidance = "";
  try {
    const recentFeedback = await db
      .select({ feedback: responseFeedback.feedback })
      .from(responseFeedback)
      .innerJoin(aiResponses, eq(responseFeedback.responseId, aiResponses.id))
      .innerJoin(leads, eq(aiResponses.leadId, leads.id))
      .innerJoin(campaigns, eq(leads.campaignId, campaigns.id))
      .where(eq(campaigns.businessId, biz.id))
      .orderBy(responseFeedback.id)
      .limit(20);

    const negCount = recentFeedback.filter(f => f.feedback !== "positive").length;
    const salesyCount = recentFeedback.filter(f => f.feedback === "too_salesy").length;
    const total = recentFeedback.length;

    if (total > 0) {
      if (salesyCount > total * 0.3) {
        feedbackGuidance = "\nIMPORTANT: Previous responses for this business were rated as too salesy. Be EXTRA subtle - barely mention the business. Focus 90% on being helpful and only naturally mention the business if it truly fits.";
      } else if (negCount > total * 0.5) {
        feedbackGuidance = "\nIMPORTANT: Previous responses had mixed reviews. Focus on being more genuine, helpful, and less promotional. The recommendation should feel organic, not forced.";
      }
    }
  } catch (err) {
  }

  const responsePrompt = `You are writing a response to a ${platformContext} post in a community group. Your goal is to be genuinely helpful while subtly recommending a business.

The post: "${postText}"
${groupName ? `Group: "${groupName}"` : ""}

Business to recommend: ${biz.name}
What they do: ${biz.coreOffering}
Tone: ${toneMap[biz.preferredTone] || "friendly and helpful"}
${feedbackGuidance}

Write a natural, human-sounding response (2-3 sentences). Do NOT make it sound like an ad. Sound like a real person sharing a helpful recommendation based on personal experience or knowledge. Include the business name naturally.

Return ONLY the response text, no quotes or formatting.`;

  const responseResult = await generateContent({
    model: "gemini-2.5-pro",
    contents: responsePrompt,
    config: { maxOutputTokens: 8192 },
  });

  const responseText = responseResult.text.trim();

  const activeCampaign = biz.campaigns[0];
  let savedResponseId: number | null = null;

  if (activeCampaign) {
    try {
      const [savedLead] = await db.insert(leads).values({
        campaignId: activeCampaign.id,
        platform: platform || "unknown",
        groupName: groupName || "Unknown Group",
        authorName: "via Telegram",
        originalPost: postText,
        postUrl: postUrl || null,
        intentScore: match.intent_score,
        status: "matched",
      }).returning();

      if (savedLead) {
        const [savedResponse] = await db.insert(aiResponses).values({
          leadId: savedLead.id,
          content: responseText,
          status: "pending",
        }).returning();
        savedResponseId = savedResponse?.id || null;
      }
    } catch (err) {
      console.error("Error saving lead/response to DB:", err);
    }
  }

  const scoreBar = "*".repeat(match.intent_score) + "_".repeat(10 - match.intent_score);
  const platformLabel = platform === "reddit" ? "Reddit" : platform === "facebook" ? "Facebook" : "Post";

  let msg = `<b>Lead Matched!</b>\n\n`;
  msg += `<b>Business:</b> ${escapeHtml(biz.name)}\n`;
  if (platform) msg += `<b>Platform:</b> ${platformLabel}\n`;
  if (groupName) msg += `<b>Group:</b> ${escapeHtml(groupName)}\n`;
  msg += `<b>Intent:</b> ${scoreBar} ${match.intent_score}/10\n`;
  msg += `<b>Why:</b> ${escapeHtml(match.reasoning)}\n\n`;
  msg += `<b>Original post:</b>\n<i>"${escapeHtml(postText.length > 300 ? postText.slice(0, 300) + "..." : postText)}"</i>`;

  if (postUrl) {
    msg += `\n\nTap "Open Post" below, then paste the reply.`;
  }

  return {
    message: msg,
    responseText,
    postUrl: postUrl || null,
    platform,
    responseId: savedResponseId,
    needsGroupContext: false,
  };
}


============================================================
FILE: server/telegram/bookmarklets.ts (97 lines)
============================================================
import crypto from "crypto";

export function generateScanToken(chatId: string, businessId: number): string {
  const secret = process.env.SESSION_SECRET || "gemin-eye-default";
  return crypto.createHmac("sha256", secret).update(`${chatId}:${businessId}`).digest("hex").slice(0, 32);
}

function buildRelaySetup(baseUrlVar: string, apiVar: string): string {
  return `var relayUrl=${baseUrlVar}+'/relay.html';` +
    `var relay=window.open(relayUrl,'gemin_eye_relay','width=300,height=120,top=50,right=50');` +
    `if(!relay||relay.closed){alert('Please allow popups for this page, then try again.');window.__geminEyeActive=false;window.__geminEyeLiActive=false;return}` +
    `var msgCounter=0;var pendingCallbacks={};` +
    `window.addEventListener('message',function(ev){if(!ev.data||ev.data.type!=='gemin-eye-result')return;var cb=pendingCallbacks[ev.data.msgId];if(cb){delete pendingCallbacks[ev.data.msgId];cb(ev.data.data)}});` +
    `function sendToApi(payload,onSuccess,onFail){` +
      `var id='m'+(++msgCounter);` +
      `pendingCallbacks[id]=function(d){onSuccess(d)};` +
      `setTimeout(function(){if(pendingCallbacks[id]){delete pendingCallbacks[id];onFail('timeout')}},30000);` +
      `try{relay.postMessage({type:'gemin-eye-scan',apiUrl:${apiVar},payload:payload,msgId:id},'*')}catch(e){delete pendingCallbacks[id];onFail('relay_closed')}` +
    `}`;
}

export function generateLinkedInBookmarkletCode(baseUrl: string, chatId: string, businessId: number, token: string): string {
  const apiUrl = `${baseUrl}/api/li-scan`;
  const relaySetup = buildRelaySetup('BASE', 'API');
  const code = `javascript:void((function(){` +
    `if(window.__geminEyeLiActive){alert('Gemin-Eye is already scanning this page. Click X on the banner to stop first.');return}` +
    `window.__geminEyeLiActive=true;` +
    `var CID='${chatId}',BID=${businessId},TOK='${token}',API='${apiUrl}',BASE='${baseUrl}';` +
    `var seenPosts={},scannedCount=0,sentCount=0,pendingCount=0,failCount=0,autoScrolling=true,scrollsDone=0,maxScrolls=150,noNewCount=0;` +
    `${relaySetup}` +
    `var banner=document.createElement('div');banner.id='gemin-eye-li-banner';` +
    `banner.style.cssText='position:fixed;top:0;left:0;width:100%;background:linear-gradient(135deg,#0077B5,#00A0DC);color:white;padding:10px 20px;z-index:2147483647;font-family:system-ui,sans-serif;font-size:14px;font-weight:600;box-shadow:0 2px 8px rgba(0,0,0,0.2);display:flex;align-items:center;justify-content:center;gap:10px;';` +
    `var counter=document.createElement('span');counter.style.cssText='font-weight:normal;opacity:0.85;font-size:13px;';counter.textContent='0 scanned';` +
    `function updateCounter(){var t=scannedCount+' scanned, '+sentCount+' leads';if(failCount>0)t+=', '+failCount+' failed';if(pendingCount>0)t+=' ('+pendingCount+' checking...)';if(!autoScrolling&&scrollsDone>=maxScrolls)t+=' - Done';counter.textContent=t}` +
    `var pauseBtn=document.createElement('span');pauseBtn.textContent='Pause';` +
    `pauseBtn.style.cssText='cursor:pointer;background:rgba(255,255,255,0.25);padding:4px 14px;border-radius:4px;font-size:12px;font-weight:700;';` +
    `pauseBtn.onclick=function(){autoScrolling=!autoScrolling;pauseBtn.textContent=autoScrolling?'Pause':'Resume'};` +
    `var closeBtn=document.createElement('span');closeBtn.textContent='[X] Close';` +
    `closeBtn.style.cssText='cursor:pointer;background:rgba(255,0,0,0.35);padding:4px 12px;border-radius:4px;font-size:12px;font-weight:700;margin-left:4px;';` +
    `closeBtn.onclick=function(){banner.remove();window.__geminEyeLiActive=false;autoScrolling=false;clearInterval(si);clearInterval(scrollInterval);try{relay.close()}catch(e){}};` +
    `banner.appendChild(document.createTextNode('Gemin-Eye LinkedIn '));banner.appendChild(counter);banner.appendChild(pauseBtn);banner.appendChild(closeBtn);` +
    `document.body.appendChild(banner);` +
    `function extractPosts(){var found=[];var els=document.querySelectorAll('.feed-shared-update-v2__description,.feed-shared-inline-show-more-text,.feed-shared-text,.update-components-text,span.break-words');` +
    `els.forEach(function(el){var t=(el.innerText||'').trim();if(t.length<25||t.length>5000||seenPosts[t])return;found.push({text:t,element:el})});return found}` +
    `function sendPost(text,el){seenPosts[text]=true;scannedCount++;pendingCount++;updateCounter();` +
    `var authorName='';try{var card=el.closest('.feed-shared-update-v2');if(card){var nameEl=card.querySelector('.update-components-actor__name span[aria-hidden],.feed-shared-actor__name span');if(nameEl)authorName=nameEl.innerText||''}}catch(e){}` +
    `var payload={chatId:CID,businessId:BID,token:TOK,postText:text,authorName:authorName||'LinkedIn user',pageUrl:window.location.href};` +
    `sendToApi(payload,function(d){pendingCount--;if(d.matched){sentCount++;el.style.outline='3px solid #0077B5';el.style.outlineOffset='4px';el.style.borderRadius='4px'}updateCounter()},function(reason){pendingCount--;failCount++;updateCounter()})}` +
    `function scan(){var posts=extractPosts();if(posts.length===0)noNewCount++;else noNewCount=0;posts.forEach(function(p){if(scannedCount>=500)return;sendPost(p.text,p.element)});if(scannedCount>=500||noNewCount>=10){autoScrolling=false;clearInterval(scrollInterval);updateCounter()}}` +
    `scan();var si=setInterval(scan,2000);` +
    `var scrollInterval=setInterval(function(){if(!autoScrolling)return;scrollsDone++;if(scrollsDone>=maxScrolls){autoScrolling=false;clearInterval(scrollInterval);updateCounter();return}window.scrollBy({top:600,behavior:'smooth'})},1500)` +
    `})())`;
  return code;
}

export function generateBookmarkletCode(baseUrl: string, chatId: string, businessId: number, token: string): string {
  const apiUrl = `${baseUrl}/api/fb-scan`;
  const relaySetup = buildRelaySetup('BASE', 'API');
  const code = `javascript:void((function(){` +
    `if(window.__geminEyeActive){alert('Gemin-Eye is already scanning this page. Click X on the banner to stop first.');return}` +
    `window.__geminEyeActive=true;` +
    `var CID='${chatId}',BID=${businessId},TOK='${token}',API='${apiUrl}',BASE='${baseUrl}';` +
    `var seenPosts={},scannedCount=0,sentCount=0,pendingCount=0,failCount=0,autoScrolling=true,scrollsDone=0,maxScrolls=150,noNewCount=0;` +
    `${relaySetup}` +
    `var banner=document.createElement('div');banner.id='gemin-eye-banner';` +
    `banner.style.cssText='position:fixed;top:0;left:0;width:100%;background:linear-gradient(135deg,#4338ca,#6d28d9);color:white;padding:10px 20px;z-index:2147483647;font-family:system-ui,sans-serif;font-size:14px;font-weight:600;box-shadow:0 2px 8px rgba(0,0,0,0.2);display:flex;align-items:center;justify-content:center;gap:10px;';` +
    `var counter=document.createElement('span');counter.style.cssText='font-weight:normal;opacity:0.85;font-size:13px;';counter.textContent='0 scanned';` +
    `function updateCounter(){var t=scannedCount+' scanned, '+sentCount+' leads';if(failCount>0)t+=', '+failCount+' failed';if(pendingCount>0)t+=' ('+pendingCount+' checking...)';if(!autoScrolling&&scrollsDone>=maxScrolls)t+=' - Done';counter.textContent=t}` +
    `var pauseBtn=document.createElement('span');pauseBtn.textContent='Pause';` +
    `pauseBtn.style.cssText='cursor:pointer;background:rgba(255,255,255,0.25);padding:4px 14px;border-radius:4px;font-size:12px;font-weight:700;';` +
    `pauseBtn.onclick=function(){autoScrolling=!autoScrolling;pauseBtn.textContent=autoScrolling?'Pause':'Resume'};` +
    `var closeBtn=document.createElement('span');closeBtn.textContent='[X] Close';` +
    `closeBtn.style.cssText='cursor:pointer;background:rgba(255,0,0,0.35);padding:4px 12px;border-radius:4px;font-size:12px;font-weight:700;margin-left:4px;';` +
    `closeBtn.onclick=function(){banner.remove();window.__geminEyeActive=false;autoScrolling=false;clearInterval(si);clearInterval(scrollInterval);try{relay.close()}catch(e){}};` +
    `banner.appendChild(document.createTextNode('Gemin-Eye '));banner.appendChild(counter);banner.appendChild(pauseBtn);banner.appendChild(closeBtn);` +
    `document.body.appendChild(banner);` +
    `function extractPosts(){var found=[];var els=document.querySelectorAll('div[dir="auto"]');` +
    `els.forEach(function(el){var t=(el.innerText||'').trim();if(t.length<25||t.length>5000||seenPosts[t])return;var a=el.closest('a');if(a&&a.href&&a.href.indexOf('/comment')===-1)return;found.push({text:t,element:el})});return found}` +
    `function sendPost(text,el){seenPosts[text]=true;scannedCount++;pendingCount++;updateCounter();` +
    `var groupName='';var h1=document.querySelector('h1');if(h1)groupName=h1.innerText||'';if(!groupName){var titleEl=document.querySelector('[role="banner"] a[href*="/groups/"]');if(titleEl)groupName=titleEl.innerText||''}` +
    `var payload={chatId:CID,businessId:BID,token:TOK,postText:text,groupName:groupName||document.title||'Facebook Group',pageUrl:window.location.href};` +
    `sendToApi(payload,function(d){pendingCount--;if(d.matched){sentCount++;el.style.outline='3px solid #6d28d9';el.style.outlineOffset='4px';el.style.borderRadius='4px'}updateCounter()},function(reason){pendingCount--;failCount++;updateCounter()})}` +
    `function scan(){var posts=extractPosts();if(posts.length===0)noNewCount++;else noNewCount=0;posts.forEach(function(p){if(scannedCount>=500)return;sendPost(p.text,p.element)});if(scannedCount>=500||noNewCount>=10){autoScrolling=false;clearInterval(scrollInterval);updateCounter()}}` +
    `scan();var si=setInterval(scan,2000);` +
    `var scrollInterval=setInterval(function(){if(!autoScrolling)return;scrollsDone++;if(scrollsDone>=maxScrolls){autoScrolling=false;clearInterval(scrollInterval);updateCounter();return}window.scrollBy({top:600,behavior:'smooth'})},1500)` +
    `})())`;
  return code;
}

export function getAppBaseUrl(): string {
  const replitDevDomain = process.env.REPLIT_DEV_DOMAIN;
  if (replitDevDomain) return `https://${replitDevDomain}`;
  const replSlug = process.env.REPL_SLUG;
  const replOwner = process.env.REPL_OWNER;
  if (replSlug && replOwner) return `https://${replSlug}.${replOwner}.repl.co`;
  return "https://gemin-eye.com";
}


============================================================
FILE: server/telegram/client-wizard.ts (238 lines)
============================================================
import { sendTelegramMessage, sendTelegramMessageToChat } from "../telegram";
import { storage } from "../storage";
import { generateContent, safeParseJsonFromAI } from "../utils/ai";
import { escapeHtml } from "../utils/html";
import { clientWizards, type ClientWizardState } from "./state";
import { generateScanToken, generateBookmarkletCode, generateLinkedInBookmarkletCode, getAppBaseUrl } from "./bookmarklets";

export async function handleClientWizard(chatId: string, text: string): Promise<boolean> {
  const wizard = clientWizards.get(chatId);
  if (!wizard) return false;

  if (text.startsWith("/")) {
    clientWizards.delete(chatId);
    return false;
  }

  wizard.timestamp = Date.now();

  switch (wizard.step) {
    case "name": {
      const name = text.trim();
      if (name.length < 2 || name.length > 100) {
        await sendTelegramMessageToChat(chatId, "Please enter a valid business name (2-100 characters).");
        return true;
      }
      wizard.name = name;
      wizard.step = "offering";
      await sendTelegramMessageToChat(chatId,
        `Got it: <b>${escapeHtml(wizard.name)}</b>\n\nIn one sentence, what does ${escapeHtml(wizard.name)} do or sell?\n<i>(e.g., "Classic American diner with all-day breakfast and comfort food")</i>`
      );
      return true;
    }

    case "offering": {
      const offering = text.trim();
      if (offering.length < 5) {
        await sendTelegramMessageToChat(chatId, "Please describe what the business does in at least a few words.");
        return true;
      }
      wizard.offering = offering;
      wizard.step = "contact";
      await sendTelegramMessageToChat(chatId,
        `Got it.\n\nNow I need your contact info. Please send your <b>email</b>, <b>phone</b>, and <b>website</b> (one per line):\n\n<i>Example:\njoe@mybusiness.com\n(312) 555-1234\nhttps://mybusiness.com</i>\n\n(If no website, just send email and phone on two lines)`
      );
      return true;
    }

    case "contact": {
      const lines = text.split("\n").map(l => l.trim()).filter(l => l.length > 0);
      if (lines.length < 2) {
        await sendTelegramMessageToChat(chatId, "Please send at least your email and phone number, one per line.");
        return true;
      }
      const emailLine = lines.find(l => l.includes("@")) || lines[0];
      const phoneLine = lines.find(l => /[\d\(\)\-\+]/.test(l) && !l.includes("@") && !l.includes(".com") && !l.includes("http")) || lines[1];
      const websiteLine = lines.find(l => l.includes(".") && !l.includes("@") && l !== phoneLine) || "";

      wizard.contactEmail = emailLine;
      wizard.contactPhone = phoneLine;
      wizard.website = websiteLine;
      wizard.step = "location";
      await sendTelegramMessageToChat(chatId,
        `Got it.\n\nWhat's the reach of ${escapeHtml(wizard.name!)}? This helps me find the right communities to monitor.\n<i>(e.g., "Chicago IL", "National", "Global / web-based")</i>`
      );
      return true;
    }

    case "location": {
      const location = text.trim();
      if (location.length < 2) {
        await sendTelegramMessageToChat(chatId, "Please enter a location (city/state, or 'online' if not location-specific).");
        return true;
      }
      wizard.location = location;
      wizard.step = "keywords";
      await sendTelegramMessageToChat(chatId,
        `Perfect.\n\nNow give me 3-5 keywords to watch for, separated by commas.\n<i>(e.g., estate planning, trust attorney, wills and trusts, probate lawyer)</i>`
      );
      return true;
    }

    case "keywords": {
      wizard.keywords = text.split(",").map(k => k.trim()).filter(k => k.length > 0);
      if (wizard.keywords.length < 1) {
        await sendTelegramMessageToChat(chatId, "Please enter at least one keyword, separated by commas.");
        return true;
      }

      await sendTelegramMessageToChat(chatId, `Got it! Setting up your monitor now...`);

      const locationInfo = wizard.location || "Online";
      const biz = await storage.createBusiness({
        userId: `tg-${chatId}`,
        name: wizard.name!,
        type: wizard.offering || wizard.name!,
        contactEmail: wizard.contactEmail || null,
        contactPhone: wizard.contactPhone || null,
        website: wizard.website || null,
        targetAudience: locationInfo,
        coreOffering: wizard.offering || wizard.name!,
        preferredTone: "casual",
      });

      let redditSubs: string[] = [];
      try {
        const groupResult = await generateContent({
          model: "gemini-2.5-flash",
          contents: `A business needs REAL Reddit subreddits to monitor for customer leads.

Business: ${wizard.name}
Offering: ${wizard.offering}
Location: ${locationInfo}
Keywords: ${wizard.keywords.join(", ")}

Return ONLY valid JSON: {"subreddits": ["r/example1", "r/example2"]}

RULES:
- List 5-8 REAL Reddit subreddits that actually exist.
- NEVER use placeholders like "r/[yourcity]". Use specific real names.
- If the business has a specific local area, include the local city/region subreddit (e.g., r/chicago, r/austin, r/nyc).
- If the business is national or global/web-based, focus on industry and topic subreddits instead of geographic ones.
- Focus on communities where people ask for recommendations related to this business.`,
          config: { maxOutputTokens: 256 },
        });
        const groupJson = safeParseJsonFromAI(groupResult.text);
        if (groupJson?.subreddits?.length > 0) {
          redditSubs = groupJson.subreddits;
        }
      } catch (e) {
        console.error("Client wizard AI group gen failed:", e);
      }
      if (redditSubs.length === 0) {
        redditSubs = ["r/smallbusiness", "r/Entrepreneur"];
      }

      await storage.createCampaign({
        businessId: biz.id,
        name: `${wizard.name} - Facebook`,
        platform: "Facebook",
        status: "active",
        strategy: `Monitor Facebook groups for leads matching ${wizard.name}`,
        targetGroups: [],
        keywords: wizard.keywords,
      });

      await storage.createCampaign({
        businessId: biz.id,
        name: `${wizard.name} - LinkedIn`,
        platform: "LinkedIn",
        status: "active",
        strategy: `Monitor LinkedIn feed for leads matching ${wizard.name}`,
        targetGroups: [],
        keywords: wizard.keywords,
      });

      await storage.createCampaign({
        businessId: biz.id,
        name: `${wizard.name} - Reddit`,
        platform: "Reddit",
        status: "active",
        strategy: `Monitor Reddit communities for leads matching ${wizard.name}`,
        targetGroups: redditSubs,
        keywords: wizard.keywords,
      });

      clientWizards.delete(chatId);

      const baseUrl = getAppBaseUrl();
      const token = generateScanToken(chatId, biz.id);
      const fbBookmarkletCode = generateBookmarkletCode(baseUrl, chatId, biz.id, token);
      const liBookmarkletCode = generateLinkedInBookmarkletCode(baseUrl, chatId, biz.id, token);

      await sendTelegramMessageToChat(chatId,
        `<b>Setup Complete!</b>\n\n` +
        `<b>Location:</b> ${escapeHtml(locationInfo)}\n` +
        `I am now watching for: <b>${wizard.keywords.map(k => escapeHtml(k)).join(", ")}</b>\n\n` +
        `<b>Reddit Monitoring:</b> ${redditSubs.map(s => escapeHtml(s)).join(", ")}\n\n` +
        `<b>Facebook Spy Glass</b>\n` +
        `To scan Facebook Groups, create a browser bookmark with this code as the URL:\n\n` +
        `1. Right-click your bookmarks bar\n` +
        `2. Click "Add bookmark"\n` +
        `3. Name it: <b>Scan FB Group</b>\n` +
        `4. Paste this as the URL:`
      );

      await sendTelegramMessageToChat(chatId, `<code>${escapeHtml(fbBookmarkletCode)}</code>`);

      await sendTelegramMessageToChat(chatId,
        `<b>LinkedIn Spy Glass</b>\n` +
        `Same idea for LinkedIn! Create a second bookmark:\n\n` +
        `1. Right-click your bookmarks bar\n` +
        `2. Click "Add bookmark"\n` +
        `3. Name it: <b>Scan LinkedIn</b>\n` +
        `4. Paste this as the URL:`
      );

      await sendTelegramMessageToChat(chatId, `<code>${escapeHtml(liBookmarkletCode)}</code>`);

      await sendTelegramMessageToChat(chatId,
        `<b>How to use the bookmarklets:</b>\n` +
        `1. Go to any Facebook Group or LinkedIn feed/search\n` +
        `2. Click the matching bookmark\n` +
        `3. It auto-scrolls and scans posts\n` +
        `4. I'll message you here instantly when I spot a lead!`
      );

      await sendTelegramMessageToChat(chatId,
        `<b>What happens automatically:</b>\n` +
        `- Reddit is scanned every 5 minutes for posts matching your keywords\n` +
        `- When a lead is found, I'll send you an AI-written response here\n` +
        `- Tap the response buttons to give feedback and improve future responses\n\n` +
        `<b>Manual scanning:</b>\n` +
        `- Send me any post URL + text and I'll analyze it instantly\n` +
        `- Or just screenshot a post and send the image - I can read it!\n\n` +
        `<b>Commands:</b>\n` +
        `/help - Full usage guide\n` +
        `/setup - Run this wizard again\n\n` +
        `You're all set! I'll message you the moment I find a lead.`
      );

      await sendTelegramMessage(
        `<b>New Client Onboarded via Wizard</b>\n\n` +
        `<b>Business:</b> ${escapeHtml(biz.name)}\n` +
        `<b>Email:</b> ${escapeHtml(wizard.contactEmail || "N/A")}\n` +
        `<b>Phone:</b> ${escapeHtml(wizard.contactPhone || "N/A")}\n` +
        `<b>Website:</b> ${escapeHtml(wizard.website || "N/A")}\n` +
        `<b>Location:</b> ${escapeHtml(locationInfo)}\n` +
        `<b>Telegram ID:</b> ${chatId}\n` +
        `<b>Keywords:</b> ${wizard.keywords.map(k => escapeHtml(k)).join(", ")}\n` +
        `<b>Reddit:</b> ${redditSubs.map(s => escapeHtml(s)).join(", ")}`
      );

      return true;
    }
  }

  return false;
}


============================================================
FILE: server/telegram/admin-commands.ts (569 lines)
============================================================
import { db } from "../db";
import { businesses, campaigns, leads, aiResponses } from "@shared/schema";
import { eq } from "drizzle-orm";
import { sendTelegramMessage } from "../telegram";
import { storage } from "../storage";
import { generateContent, safeParseJsonFromAI } from "../utils/ai";
import { escapeHtml } from "../utils/html";
import { postRedditSubmission, isRedditConfigured } from "../reddit-poster";
import { pendingClientSetups, type AdminSetupState } from "./state";
import { getAllBusinessesWithCampaigns } from "./analysis";

export async function handleAdminCommand(chatId: string, text: string): Promise<boolean> {
  const pending = pendingClientSetups.get(chatId);

  if (pending && !text.startsWith("/")) {
    return await handleClientSetupFlow(chatId, text, pending);
  }

  if (pending && text.startsWith("/")) {
    pendingClientSetups.delete(chatId);
  }

  if (text === "/newclient") {
    pendingClientSetups.set(chatId, { step: "name", timestamp: Date.now() });
    await sendTelegramMessage("<b>New Client Setup</b>\n\nWhat's the business name?");
    return true;
  }

  if (text === "/removeclient") {
    const allBiz = await getAllBusinessesWithCampaigns();
    if (allBiz.length === 0) {
      await sendTelegramMessage("No businesses to remove.");
      return true;
    }

    let msg = `<b>Remove a Client</b>\n\nReply with the number of the business to remove:\n\n`;
    allBiz.forEach((b, i) => {
      msg += `<b>${i + 1}.</b> ${escapeHtml(b.name)} (${escapeHtml(b.type)})\n`;
    });
    msg += `\nOr type /cancel to go back.`;

    pendingClientSetups.set(chatId, { step: "remove_select", timestamp: Date.now() });
    await sendTelegramMessage(msg);
    return true;
  }

  if (text === "/keywords") {
    const allBiz = await getAllBusinessesWithCampaigns();
    if (allBiz.length === 0) {
      await sendTelegramMessage("No businesses set up. Use /newclient first.");
      return true;
    }

    let msg = `<b>Update Keywords</b>\n\nWhich business? Reply with the number:\n\n`;
    allBiz.forEach((b, i) => {
      const kws = b.campaigns.flatMap((c) => c.keywords).slice(0, 8);
      msg += `<b>${i + 1}.</b> ${escapeHtml(b.name)}\n    Current: ${kws.map(k => escapeHtml(k)).join(", ")}\n\n`;
    });
    msg += `Or type /cancel to go back.`;

    pendingClientSetups.set(chatId, { step: "keywords_select", timestamp: Date.now() });
    await sendTelegramMessage(msg);
    return true;
  }

  if (text === "/groups") {
    const allBiz = await getAllBusinessesWithCampaigns();
    if (allBiz.length === 0) {
      await sendTelegramMessage("No businesses set up. Use /newclient first.");
      return true;
    }

    let msg = `<b>Update Target Groups</b>\n\nWhich business? Reply with the number:\n\n`;
    allBiz.forEach((b, i) => {
      const grps = b.campaigns.flatMap((c) => c.targetGroups).slice(0, 5);
      msg += `<b>${i + 1}.</b> ${escapeHtml(b.name)}\n    Current: ${grps.map(g => escapeHtml(g)).join(", ")}\n\n`;
    });
    msg += `Or type /cancel to go back.`;

    pendingClientSetups.set(chatId, { step: "groups_select", timestamp: Date.now() });
    await sendTelegramMessage(msg);
    return true;
  }

  if (text === "/cancel") {
    pendingClientSetups.delete(chatId);
    await sendTelegramMessage("Cancelled.");
    return true;
  }

  if (text === "/addalert") {
    const allBiz = await getAllBusinessesWithCampaigns();
    if (allBiz.length === 0) {
      await sendTelegramMessage("No businesses set up. Use /newclient first.");
      return true;
    }

    let msg = `<b>Add Google Alert Feed</b>\n\nWhich business should this alert feed be attached to?\n\n`;
    allBiz.forEach((b, i) => {
      msg += `<b>${i + 1}.</b> ${escapeHtml(b.name)}\n`;
    });
    msg += `\nReply with the number, or /cancel.`;

    pendingClientSetups.set(chatId, { step: "alert_select", timestamp: Date.now() });
    await sendTelegramMessage(msg);
    return true;
  }

  if (text === "/alerts") {
    const allBiz = await getAllBusinessesWithCampaigns();
    const allCamps = await db.select().from(campaigns);

    const alertCamps = allCamps.filter(c => c.platform.toLowerCase() === "google_alerts" && c.status === "active");
    if (alertCamps.length === 0) {
      await sendTelegramMessage(
        `<b>No Google Alert feeds configured.</b>\n\n` +
        `To add one:\n` +
        `1. Go to <a href="https://google.com/alerts">google.com/alerts</a>\n` +
        `2. Enter your search query (e.g., <code>site:quora.com "best pizza"</code>)\n` +
        `3. Click "Show Options" and set Deliver to: <b>RSS Feed</b>\n` +
        `4. Copy the RSS feed URL\n` +
        `5. Use /addalert to add it here`
      );
      return true;
    }

    let msg = `<b>Your Google Alert Feeds:</b>\n\n`;
    for (const camp of alertCamps) {
      const biz = allBiz.find(b => b.id === camp.businessId);
      const feeds = (camp.targetGroups as string[]) || [];
      msg += `<b>${escapeHtml(biz?.name || "Unknown")}</b>\n`;
      feeds.forEach((f, i) => {
        const shortUrl = f.length > 60 ? f.slice(0, 57) + "..." : f;
        msg += `  ${i + 1}. ${escapeHtml(shortUrl)}\n`;
      });
      msg += `\n`;
    }
    msg += `Use /addalert to add more feeds.\nUse /removealert to remove a feed.`;
    await sendTelegramMessage(msg);
    return true;
  }

  if (text === "/removealert") {
    const allCamps = await db.select().from(campaigns);
    const allBiz = await db.select().from(businesses);
    const alertCamps = allCamps.filter(c => c.platform.toLowerCase() === "google_alerts" && c.status === "active");

    if (alertCamps.length === 0) {
      await sendTelegramMessage("No Google Alert feeds to remove.");
      return true;
    }

    let msg = `<b>Remove a Google Alert Feed</b>\n\nReply with the number:\n\n`;
    let idx = 1;
    const feedIndex: Array<{ campaignId: number; feedUrl: string }> = [];
    for (const camp of alertCamps) {
      const biz = allBiz.find(b => b.id === camp.businessId);
      const feeds = (camp.targetGroups as string[]) || [];
      for (const f of feeds) {
        const shortUrl = f.length > 60 ? f.slice(0, 57) + "..." : f;
        msg += `<b>${idx}.</b> ${escapeHtml(biz?.name || "?")} - ${escapeHtml(shortUrl)}\n`;
        feedIndex.push({ campaignId: camp.id, feedUrl: f });
        idx++;
      }
    }
    msg += `\nOr /cancel.`;

    pendingClientSetups.set(chatId, { step: "alert_remove", timestamp: Date.now(), groups: feedIndex.map(fi => `${fi.campaignId}::${fi.feedUrl}`) });
    await sendTelegramMessage(msg);
    return true;
  }

  if (text.startsWith("/post ")) {
    if (!isRedditConfigured()) {
      await sendTelegramMessage("Reddit credentials not configured. Add REDDIT_CLIENT_ID, REDDIT_CLIENT_SECRET, REDDIT_USERNAME, and REDDIT_PASSWORD to your secrets.");
      return true;
    }

    const postArgs = text.slice(6).trim();
    const subredditMatch = postArgs.match(/^(r\/\w+)\s+([\s\S]+)/);

    if (!subredditMatch) {
      await sendTelegramMessage(
        `<b>Usage:</b>\n\n` +
        `<b>New post:</b>\n<code>/post r/subreddit Title here | Body text here</code>\n\n` +
        `<b>Reply to a post:</b>\nPaste a Reddit URL into the chat and I'll generate a response. Then tap "Post to Reddit" to comment.\n\n` +
        `<b>Example:</b>\n<code>/post r/startups Check out my AI tool | We built an AI that monitors communities for leads.</code>`
      );
      return true;
    }

    const subreddit = subredditMatch[1];
    const rest = subredditMatch[2].trim();

    const pipeIndex = rest.indexOf("|");
    let title: string;
    let body: string;

    if (pipeIndex > 0) {
      title = rest.slice(0, pipeIndex).trim();
      body = rest.slice(pipeIndex + 1).trim();
    } else {
      title = rest;
      body = "";
    }

    await sendTelegramMessage(`Posting to <b>${escapeHtml(subreddit)}</b>...\n\nTitle: <i>${escapeHtml(title)}</i>`);

    const result = await postRedditSubmission(subreddit, title, body);

    if (result.success) {
      let msg = "Posted to Reddit!";
      if (result.postUrl) {
        msg += `\n\n<a href="${result.postUrl}">View your post</a>`;
      }
      await sendTelegramMessage(msg);
    } else {
      await sendTelegramMessage(`Failed to post: ${result.error}`);
    }

    return true;
  }

  return false;
}

export async function handleClientSetupFlow(chatId: string, text: string, pending: AdminSetupState): Promise<boolean> {
  if (text === "/cancel") {
    pendingClientSetups.delete(chatId);
    await sendTelegramMessage("Client setup cancelled.");
    return true;
  }

  pending.timestamp = Date.now();

  switch (pending.step) {
    case "name":
      pending.name = text;
      pending.step = "type";
      await sendTelegramMessage(`Got it: <b>${escapeHtml(text)}</b>\n\nWhat type of business is this?\n<i>(e.g., "Diner in Brookfield, IL", "AI productivity tool", "Bocce ball club")</i>`);
      break;

    case "type":
      pending.type = text;
      pending.step = "audience";
      await sendTelegramMessage(`Business type: <b>${escapeHtml(text)}</b>\n\nWho is the target audience?\n<i>(e.g., "Families in the Western Suburbs looking for casual dining")</i>`);
      break;

    case "audience":
      pending.audience = text;
      pending.step = "offering";
      await sendTelegramMessage(`Target audience set.\n\nDescribe what this business offers in 1-2 sentences:\n<i>(e.g., "Classic American diner serving hearty breakfasts and comfort food. Family-owned with generous portions.")</i>`);
      break;

    case "offering":
      pending.offering = text;
      pending.step = "tone";
      await sendTelegramMessage(`Got the offering.\n\nWhat tone should AI responses use?\n\n<b>1.</b> Casual (friendly, approachable)\n<b>2.</b> Empathetic (warm, supportive)\n<b>3.</b> Professional (authoritative, informative)\n\nReply with 1, 2, or 3.`);
      break;

    case "tone": {
      const toneChoice = text.trim();
      if (toneChoice === "1") pending.tone = "casual";
      else if (toneChoice === "2") pending.tone = "empathetic";
      else if (toneChoice === "3") pending.tone = "professional";
      else pending.tone = "casual";

      pending.step = "keywords";
      await sendTelegramMessage(`Tone: <b>${pending.tone}</b>\n\nNow list the keywords to watch for, separated by commas:\n<i>(e.g., "restaurant recommendation, best pizza, where to eat, Brookfield food")</i>`);
      break;
    }

    case "keywords": {
      pending.keywords = text.split(",").map(k => k.trim()).filter(k => k.length > 0);

      await sendTelegramMessage(`Keywords: ${pending.keywords.map(k => `<b>${escapeHtml(k)}</b>`).join(", ")}\n\nGenerating target communities with AI...`);

      let aiGroups: string[] = [];
      try {
        const groupResult = await generateContent({
          model: "gemini-2.5-flash",
          contents: `You are a social media expert. A business needs REAL Reddit subreddits and Facebook groups to monitor for customer acquisition leads.

Business: ${pending.name} (${pending.type})
Target audience: ${pending.audience}
Offering: ${pending.offering}
Keywords: ${(pending.keywords || []).join(", ")}

Return ONLY valid JSON with this structure:
{"subreddits": ["r/example1", "r/example2"], "facebook_groups": ["Example Group Name"]}

RULES:
- List 5-8 REAL Reddit subreddits that actually exist where the target audience asks questions or seeks recommendations.
- NEVER use placeholders like "r/[yourcity]". Use REAL specific names like "r/chicago", "r/fitness", "r/smallbusiness".
- List 2-3 relevant Facebook group names.
- Focus on communities where people actively ask for recommendations related to this business.`,
          config: { maxOutputTokens: 512 },
        });
        const groupJson = safeParseJsonFromAI(groupResult.text);
        if (groupJson) {
          aiGroups = [
            ...(groupJson.subreddits || []),
            ...(groupJson.facebook_groups || []),
          ];
        }
      } catch (e) {
        console.error("AI group generation failed:", e);
      }

      if (aiGroups.length === 0) {
        aiGroups = ["r/smallbusiness", "r/Entrepreneur"];
      }

      pending.groups = aiGroups;

      const biz = await storage.createBusiness({
        userId: "telegram-admin",
        name: pending.name!,
        type: pending.type!,
        targetAudience: pending.audience!,
        coreOffering: pending.offering!,
        preferredTone: pending.tone!,
      });

      const redditGroups = pending.groups.filter(g => g.toLowerCase().startsWith("r/"));
      const facebookGroups = pending.groups.filter(g => !g.toLowerCase().startsWith("r/"));

      if (facebookGroups.length > 0) {
        await storage.createCampaign({
          businessId: biz.id,
          name: `${pending.name} - Facebook`,
          platform: "Facebook",
          status: "active",
          strategy: `Monitor Facebook groups for ${pending.type} leads`,
          targetGroups: facebookGroups,
          keywords: pending.keywords || [],
        });
      }

      if (redditGroups.length > 0) {
        await storage.createCampaign({
          businessId: biz.id,
          name: `${pending.name} - Reddit`,
          platform: "Reddit",
          status: "active",
          strategy: `Monitor Reddit communities for ${pending.type} leads`,
          targetGroups: redditGroups,
          keywords: pending.keywords || [],
        });
      }

      if (facebookGroups.length === 0 && redditGroups.length === 0) {
        await storage.createCampaign({
          businessId: biz.id,
          name: `${pending.name} - General`,
          platform: "Reddit",
          status: "active",
          strategy: `Monitor communities for ${pending.type} leads`,
          targetGroups: pending.groups,
          keywords: pending.keywords || [],
        });
      }

      pendingClientSetups.delete(chatId);

      let msg = `<b>Client Created!</b>\n\n`;
      msg += `<b>Name:</b> ${escapeHtml(biz.name)}\n`;
      msg += `<b>Type:</b> ${escapeHtml(biz.type)}\n`;
      msg += `<b>Tone:</b> ${escapeHtml(pending.tone!)}\n`;
      msg += `<b>Keywords:</b> ${(pending.keywords || []).map(k => escapeHtml(k)).join(", ")}\n`;
      msg += `<b>Auto-Generated Groups:</b> ${(pending.groups || []).map(g => escapeHtml(g)).join(", ")}\n\n`;
      msg += `I'm now watching for leads for <b>${escapeHtml(biz.name)}</b>. Send me posts to analyze!\n`;
      msg += `\n<i>Use /groups to view or change target communities.</i>`;

      await sendTelegramMessage(msg);
      break;
    }

    case "remove_select": {
      const allBiz = await getAllBusinessesWithCampaigns();
      const idx = parseInt(text) - 1;
      if (isNaN(idx) || idx < 0 || idx >= allBiz.length) {
        await sendTelegramMessage("Invalid number. Try again or /cancel.");
        return true;
      }

      const bizToRemove = allBiz[idx];
      const allCampsToRemove = bizToRemove.campaigns;

      for (const camp of allCampsToRemove) {
        const campLeads = await db.select().from(leads).where(eq(leads.campaignId, camp.id));
        for (const lead of campLeads) {
          await db.delete(aiResponses).where(eq(aiResponses.leadId, lead.id));
        }
        await db.delete(leads).where(eq(leads.campaignId, camp.id));
        await db.delete(campaigns).where(eq(campaigns.id, camp.id));
      }
      await db.delete(businesses).where(eq(businesses.id, bizToRemove.id));

      pendingClientSetups.delete(chatId);
      await sendTelegramMessage(`<b>${escapeHtml(bizToRemove.name)}</b> has been removed along with all its campaigns, leads, and responses.`);
      break;
    }

    case "keywords_select": {
      const allBiz = await getAllBusinessesWithCampaigns();
      const idx = parseInt(text) - 1;
      if (isNaN(idx) || idx < 0 || idx >= allBiz.length) {
        await sendTelegramMessage("Invalid number. Try again or /cancel.");
        return true;
      }

      pending.name = allBiz[idx].name;
      pending.step = "keywords_update";
      const currentKws = allBiz[idx].campaigns.flatMap(c => c.keywords);
      await sendTelegramMessage(`<b>Updating keywords for ${escapeHtml(allBiz[idx].name)}</b>\n\nCurrent keywords: ${currentKws.map(k => escapeHtml(k)).join(", ")}\n\nSend the new complete list of keywords, separated by commas:\n<i>(This will replace all current keywords)</i>`);
      break;
    }

    case "keywords_update": {
      const newKeywords = text.split(",").map(k => k.trim()).filter(k => k.length > 0);
      const allBiz = await getAllBusinessesWithCampaigns();
      const biz = allBiz.find(b => b.name === pending.name);
      if (biz) {
        for (const camp of biz.campaigns) {
          await db.update(campaigns).set({ keywords: newKeywords }).where(eq(campaigns.id, camp.id));
        }
      }

      pendingClientSetups.delete(chatId);
      await sendTelegramMessage(`<b>Keywords updated for ${escapeHtml(pending.name!)}</b>\n\nNew keywords: ${newKeywords.map(k => escapeHtml(k)).join(", ")}`);
      break;
    }

    case "groups_select": {
      const allBiz = await getAllBusinessesWithCampaigns();
      const idx = parseInt(text) - 1;
      if (isNaN(idx) || idx < 0 || idx >= allBiz.length) {
        await sendTelegramMessage("Invalid number. Try again or /cancel.");
        return true;
      }

      pending.name = allBiz[idx].name;
      pending.step = "groups_update";
      const currentGroups = allBiz[idx].campaigns.flatMap(c => c.targetGroups);
      await sendTelegramMessage(`<b>Updating groups for ${escapeHtml(allBiz[idx].name)}</b>\n\nCurrent groups: ${currentGroups.map(g => escapeHtml(g)).join(", ")}\n\nSend the new complete list of groups/subreddits, separated by commas:\n<i>(This will replace all current groups)</i>`);
      break;
    }

    case "groups_update": {
      const newGroups = text.split(",").map(g => g.trim()).filter(g => g.length > 0);
      const allBiz = await getAllBusinessesWithCampaigns();
      const biz = allBiz.find(b => b.name === pending.name);
      if (biz) {
        for (const camp of biz.campaigns) {
          await db.update(campaigns).set({ targetGroups: newGroups }).where(eq(campaigns.id, camp.id));
        }
      }

      pendingClientSetups.delete(chatId);
      await sendTelegramMessage(`<b>Groups updated for ${escapeHtml(pending.name!)}</b>\n\nNew groups: ${newGroups.map(g => escapeHtml(g)).join(", ")}`);
      break;
    }

    case "alert_select": {
      const allBiz = await getAllBusinessesWithCampaigns();
      const idx = parseInt(text) - 1;
      if (isNaN(idx) || idx < 0 || idx >= allBiz.length) {
        await sendTelegramMessage("Invalid number. Try again or /cancel.");
        return true;
      }

      pending.name = allBiz[idx].name;
      pending.step = "alert_url";
      await sendTelegramMessage(
        `<b>Adding alert feed for ${escapeHtml(allBiz[idx].name)}</b>\n\n` +
        `Paste the Google Alert RSS feed URL:\n\n` +
        `<i>How to get it:</i>\n` +
        `1. Go to <a href="https://google.com/alerts">google.com/alerts</a>\n` +
        `2. Enter your search (e.g., <code>site:quora.com "best pizza"</code>)\n` +
        `3. Click "Show Options" and set Deliver to: <b>RSS Feed</b>\n` +
        `4. Copy the RSS URL and paste it here`,
        { disable_web_page_preview: true }
      );
      break;
    }

    case "alert_url": {
      const feedUrl = text.trim();
      if (!feedUrl.startsWith("http")) {
        await sendTelegramMessage("That doesn't look like a URL. Please paste the RSS feed URL starting with http:// or https://");
        return true;
      }

      const allBiz = await getAllBusinessesWithCampaigns();
      const biz = allBiz.find(b => b.name === pending.name);
      if (!biz) {
        pendingClientSetups.delete(chatId);
        await sendTelegramMessage("Business not found. Try again with /addalert.");
        return true;
      }

      const allCamps = await db.select().from(campaigns);
      let alertCamp = allCamps.find(c => c.businessId === biz.id && c.platform.toLowerCase() === "google_alerts" && c.status === "active");

      if (alertCamp) {
        const existingFeeds = (alertCamp.targetGroups as string[]) || [];
        if (existingFeeds.includes(feedUrl)) {
          pendingClientSetups.delete(chatId);
          await sendTelegramMessage("This feed URL is already added for this business.");
          return true;
        }
        await db.update(campaigns).set({ targetGroups: [...existingFeeds, feedUrl] }).where(eq(campaigns.id, alertCamp.id));
      } else {
        const bizKeywords = biz.campaigns.flatMap(c => c.keywords);
        await storage.createCampaign({
          businessId: biz.id,
          name: `${biz.name} - Google Alerts`,
          platform: "google_alerts",
          status: "active",
          strategy: `Monitor Google Alerts RSS feeds for ${biz.type} leads`,
          targetGroups: [feedUrl],
          keywords: bizKeywords,
        });
      }

      pendingClientSetups.delete(chatId);
      await sendTelegramMessage(
        `<b>Google Alert feed added!</b>\n\n` +
        `<b>Business:</b> ${escapeHtml(biz.name)}\n` +
        `<b>Feed:</b> ${escapeHtml(feedUrl.length > 60 ? feedUrl.slice(0, 57) + "..." : feedUrl)}\n\n` +
        `The monitor will check this feed every 2 minutes and alert you when it finds leads.\n\n` +
        `Use /alerts to see all feeds, or /addalert to add more.`
      );
      break;
    }

    case "alert_remove": {
      const idx = parseInt(text) - 1;
      const feedEntries = (pending.groups || []);
      if (isNaN(idx) || idx < 0 || idx >= feedEntries.length) {
        await sendTelegramMessage("Invalid number. Try again or /cancel.");
        return true;
      }

      const entry = feedEntries[idx];
      const [campId, ...feedUrlParts] = entry.split("::");
      const feedUrl = feedUrlParts.join("::");
      const campaignId = parseInt(campId);

      const camp = await db.select().from(campaigns).where(eq(campaigns.id, campaignId)).limit(1);
      if (camp.length > 0) {
        const existingFeeds = (camp[0].targetGroups as string[]) || [];
        const newFeeds = existingFeeds.filter(f => f !== feedUrl);
        if (newFeeds.length === 0) {
          await db.update(campaigns).set({ status: "inactive" }).where(eq(campaigns.id, campaignId));
        } else {
          await db.update(campaigns).set({ targetGroups: newFeeds }).where(eq(campaigns.id, campaignId));
        }
      }

      pendingClientSetups.delete(chatId);
      await sendTelegramMessage(`<b>Alert feed removed.</b>\n\nUse /alerts to see remaining feeds.`);
      break;
    }
  }

  return true;
}


============================================================
FILE: server/telegram/callbacks.ts (117 lines)
============================================================
import { db } from "../db";
import { aiResponses, responseFeedback } from "@shared/schema";
import { eq } from "drizzle-orm";
import { sendTelegramMessage, answerCallbackQuery, editMessageReplyMarkup } from "../telegram";
import { postRedditComment, isRedditConfigured } from "../reddit-poster";
import { pendingRedditPosts, REDDIT_POST_TTL } from "./state";

export async function handleCallbackQuery(cbq: any): Promise<void> {
  const data = cbq.data as string;
  const cbqChatId = String(cbq.message?.chat?.id || "");

  if (data.startsWith("fb_") || data.startsWith("li_")) {
    await handleFeedbackCallback(cbq, data, cbqChatId);
  } else if (data.startsWith("reddit_post_")) {
    await handleRedditPostCallback(cbq, data, cbqChatId);
  } else if (data === "noop") {
    await answerCallbackQuery(cbq.id, "Feedback already recorded.");
  } else {
    await answerCallbackQuery(cbq.id);
  }
}

async function handleFeedbackCallback(cbq: any, data: string, cbqChatId: string): Promise<void> {
  const parts = data.split("_");
  const feedbackType = parts[1];
  const responseId = parseInt(parts[2]);

  if (isNaN(responseId)) {
    await answerCallbackQuery(cbq.id);
    return;
  }

  const feedbackMap: Record<string, string> = {
    good: "positive",
    bad: "bad_match",
    salesy: "too_salesy",
    wrong: "wrong_client",
  };

  const feedbackValue = feedbackMap[feedbackType] || feedbackType;

  try {
    const existing = await db.select().from(responseFeedback).where(eq(responseFeedback.responseId, responseId)).limit(1);
    if (existing.length > 0) {
      await answerCallbackQuery(cbq.id, "Feedback already recorded for this response.");
      return;
    }

    await db.insert(responseFeedback).values({
      responseId,
      feedback: feedbackValue,
    });

    if (feedbackValue === "positive") {
      await db.update(aiResponses).set({ status: "approved", approvedAt: new Date() }).where(eq(aiResponses.id, responseId));
    }
  } catch (err) {
    console.error("Error saving feedback:", err);
  }

  const feedbackLabels: Record<string, string> = {
    positive: "Marked as used - great!",
    bad_match: "Noted: bad match. I'll learn from this.",
    too_salesy: "Noted: too salesy. I'll adjust the tone.",
    wrong_client: "Noted: wrong client matched.",
  };

  await answerCallbackQuery(cbq.id, feedbackLabels[feedbackValue] || "Feedback saved!");

  if (cbq.message?.message_id && cbqChatId) {
    const existingButtons = cbq.message?.reply_markup?.inline_keyboard || [];
    const urlButtons = existingButtons.filter((row: any[]) => row.some((b: any) => b.url));
    const selectedLabel = feedbackType === "good" ? "Used It" : feedbackType === "salesy" ? "Too Salesy" : feedbackType === "wrong" ? "Wrong Client" : "Bad Match";
    const confirmRow = [{ text: `[${selectedLabel}]`, callback_data: "noop" }];
    const newKeyboard = [...urlButtons, confirmRow];
    await editMessageReplyMarkup(cbqChatId, cbq.message.message_id, { inline_keyboard: newKeyboard });
  }
}

async function handleRedditPostCallback(cbq: any, data: string, cbqChatId: string): Promise<void> {
  const responseId = parseInt(data.replace("reddit_post_", ""));
  if (isNaN(responseId)) {
    await answerCallbackQuery(cbq.id);
    return;
  }

  const pending = pendingRedditPosts.get(responseId);
  if (!pending || (Date.now() - pending.timestamp) > REDDIT_POST_TTL) {
    pendingRedditPosts.delete(responseId);
    await answerCallbackQuery(cbq.id, "This post link has expired. Trigger a new analysis.");
    return;
  }

  await answerCallbackQuery(cbq.id, "Posting to Reddit...");
  const result = await postRedditComment(pending.postUrl, pending.responseText);
  pendingRedditPosts.delete(responseId);

  if (result.success) {
    await db.insert(responseFeedback).values({ responseId, feedback: "positive" }).catch(() => {});
    await db.update(aiResponses).set({ status: "approved", approvedAt: new Date() }).where(eq(aiResponses.id, responseId)).catch(() => {});

    let confirmMsg = "Posted to Reddit!";
    if (result.commentUrl) {
      confirmMsg += `\n\n<a href="${result.commentUrl}">View your comment</a>`;
    }
    await sendTelegramMessage(confirmMsg);

    if (cbq.message?.message_id && cbqChatId) {
      const existingButtons = cbq.message?.reply_markup?.inline_keyboard || [];
      const urlButtons = existingButtons.filter((row: any[]) => row.some((b: any) => b.url));
      const newKeyboard = [...urlButtons, [{ text: "[Posted to Reddit]", callback_data: "noop" }]];
      await editMessageReplyMarkup(cbqChatId, cbq.message.message_id, { inline_keyboard: newKeyboard });
    }
  } else {
    await sendTelegramMessage(`Failed to post: ${result.error}`);
  }
}


============================================================
FILE: server/telegram/index.ts (6 lines)
============================================================
export { handlePost, extractPostUrl, stripUrls, downloadTelegramPhotoWithMime, extractTextFromImage, getAllBusinessesWithCampaigns, type PostAnalysis } from "./analysis";
export { generateScanToken, generateBookmarkletCode, generateLinkedInBookmarkletCode, getAppBaseUrl } from "./bookmarklets";
export { handleClientWizard } from "./client-wizard";
export { handleAdminCommand } from "./admin-commands";
export { handleCallbackQuery } from "./callbacks";
export { pendingContextRequests, pendingRedditPosts, clientWizards, CONTEXT_TTL, type PendingContextRequest } from "./state";


============================================================
FILE: server/utils/ai.ts (141 lines)
============================================================
import { GoogleGenAI } from "@google/genai";
import { z, ZodSchema } from "zod";

export const ai = new GoogleGenAI({
  apiKey: process.env.AI_INTEGRATIONS_GEMINI_API_KEY,
  httpOptions: {
    apiVersion: "",
    baseUrl: process.env.AI_INTEGRATIONS_GEMINI_BASE_URL,
  },
});

const AI_TIMEOUT_MS = parseInt(process.env.AI_TIMEOUT_MS || "30000", 10);
const AI_MAX_RETRIES = parseInt(process.env.AI_MAX_RETRIES || "2", 10);

function isRetryableError(err: unknown): boolean {
  if (err instanceof Error) {
    const msg = err.message.toLowerCase();
    if (msg.includes("timed out")) return true;
    if (msg.includes("429") || msg.includes("rate limit") || msg.includes("quota")) return true;
    if (msg.includes("503") || msg.includes("500") || msg.includes("unavailable")) return true;
    if (msg.includes("econnreset") || msg.includes("econnrefused") || msg.includes("socket")) return true;
  }
  return false;
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function generateContentOnce(
  opts: { model: string; contents: any; config?: any },
  timeoutMs: number,
): Promise<{ text: string }> {
  const aiCall = ai.models.generateContent(opts);
  const timeout = new Promise<never>((_, reject) => {
    const timer = setTimeout(() => {
      reject(new Error(`AI call timed out after ${timeoutMs}ms (model: ${opts.model})`));
    }, timeoutMs);
    timer.unref?.();
  });
  const result = await Promise.race([aiCall, timeout]);
  return { text: result.text || "" };
}

export async function generateContent(
  opts: { model: string; contents: any; config?: any },
  timeoutMs: number = AI_TIMEOUT_MS,
  retries: number = AI_MAX_RETRIES,
): Promise<{ text: string }> {
  let lastError: unknown;
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      return await generateContentOnce(opts, timeoutMs);
    } catch (err) {
      lastError = err;
      if (attempt < retries && isRetryableError(err)) {
        const backoffMs = 1000 * Math.pow(2, attempt);
        console.warn(`AI call failed (attempt ${attempt + 1}/${retries + 1}, model: ${opts.model}), retrying in ${backoffMs}ms...`, err instanceof Error ? err.message : err);
        await sleep(backoffMs);
      } else if (!isRetryableError(err)) {
        throw err;
      }
    }
  }
  throw lastError;
}

export function safeParseJsonFromAI(text: string): any | null {
  const cleaned = text.replace(/```json\s*/g, "").replace(/```\s*/g, "").trim();
  const jsonMatch = cleaned.match(/\{[\s\S]*\}/);
  if (!jsonMatch) return null;
  try {
    return JSON.parse(jsonMatch[0]);
  } catch {
    return null;
  }
}

export async function parseAIJsonWithRetry<T>(
  generateFn: () => Promise<string>,
  schema: ZodSchema<T>,
  maxRetries: number = 1
): Promise<T | null> {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const text = await generateFn();
      const parsed = safeParseJsonFromAI(text);
      if (!parsed) {
        if (attempt < maxRetries) {
          console.warn(`AI JSON parse failed (attempt ${attempt + 1}), retrying...`);
          continue;
        }
        return null;
      }

      const validated = schema.safeParse(parsed);
      if (validated.success) {
        return validated.data;
      }

      console.warn(`AI JSON validation failed (attempt ${attempt + 1}):`, validated.error.issues);
      if (attempt < maxRetries) continue;

      return null;
    } catch (err) {
      console.error(`AI generation error (attempt ${attempt + 1}):`, err);
      if (attempt >= maxRetries) return null;
    }
  }
  return null;
}

export const leadScoreSchema = z.object({
  is_lead: z.boolean(),
  intent_score: z.number().min(1).max(10),
  reasoning: z.string(),
});

export type LeadScore = z.infer<typeof leadScoreSchema>;

export const strategySchema = z.object({
  platforms: z.array(z.object({ name: z.string() })),
  groups: z.array(z.string()),
  keywords: z.array(z.string()),
  sampleResponse: z.string(),
  rationale: z.string(),
});

export type Strategy = z.infer<typeof strategySchema>;

export const TONE_MAP: Record<string, string> = {
  empathetic: "empathetic, warm, and supportive",
  professional: "professional, authoritative, and informative",
  casual: "casual, friendly, and approachable",
  helpful: "helpful, knowledgeable, and conversational",
};

export const MIN_POST_LENGTH = 25;
export const MIN_SCAN_INTENT_SCORE = 4;
export const MIN_MONITOR_INTENT_SCORE = 5;
export const SALESY_FEEDBACK_THRESHOLD = 0.3;


============================================================
FILE: server/utils/html.ts (40 lines)
============================================================
export function escapeHtml(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
}

export function stripHtml(html: string): string {
  return html
    .replace(/<[^>]*>/g, " ")
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/\s+/g, " ")
    .trim();
}

export function truncate(text: string, max: number): string {
  if (text.length <= max) return text;
  return text.slice(0, max) + "...";
}

export function canonicalizeUrl(url: string): string {
  try {
    const u = new URL(url);
    u.hash = "";
    const paramsToStrip = ["utm_source", "utm_medium", "utm_campaign", "utm_term", "utm_content", "ref", "fbclid", "gclid"];
    for (const p of paramsToStrip) {
      u.searchParams.delete(p);
    }
    return u.toString();
  } catch {
    return url;
  }
}


============================================================
FILE: server/utils/feedback.ts (31 lines)
============================================================
import { db } from "../db";
import { responseFeedback, aiResponses, leads, campaigns } from "@shared/schema";
import { eq } from "drizzle-orm";
import { SALESY_FEEDBACK_THRESHOLD } from "./ai";

export async function getFeedbackGuidance(businessId: number): Promise<string> {
  try {
    const recentFeedback = await db
      .select({ feedback: responseFeedback.feedback })
      .from(responseFeedback)
      .innerJoin(aiResponses, eq(responseFeedback.responseId, aiResponses.id))
      .innerJoin(leads, eq(aiResponses.leadId, leads.id))
      .innerJoin(campaigns, eq(leads.campaignId, campaigns.id))
      .where(eq(campaigns.businessId, businessId))
      .orderBy(responseFeedback.id)
      .limit(20);

    const salesyCount = recentFeedback.filter((f) => f.feedback === "too_salesy").length;
    const negCount = recentFeedback.filter((f) => f.feedback !== "positive").length;
    const total = recentFeedback.length;

    if (total > 0) {
      if (salesyCount > total * SALESY_FEEDBACK_THRESHOLD) {
        return "\nIMPORTANT: Previous responses were rated as too salesy. Be EXTRA subtle - barely mention the business. Focus 90% on being helpful.";
      } else if (negCount > total * 0.5) {
        return "\nIMPORTANT: Previous responses had mixed reviews. Focus on being more genuine and less promotional.";
      }
    }
  } catch {}
  return "";
}


============================================================
FILE: server/utils/dedup.ts (14 lines)
============================================================
import { db } from "../db";
import { seenItems } from "@shared/schema";
import { eq } from "drizzle-orm";

export async function hasBeenSeen(dedupKey: string): Promise<boolean> {
  const existing = await db.select({ id: seenItems.id }).from(seenItems).where(eq(seenItems.dedupKey, dedupKey)).limit(1);
  return existing.length > 0;
}

export async function markSeen(dedupKey: string, source: string): Promise<void> {
  try {
    await db.insert(seenItems).values({ dedupKey, source }).onConflictDoNothing();
  } catch {}
}


============================================================
FILE: server/utils/rate-limit.ts (50 lines)
============================================================
import type { Request, Response, NextFunction } from "express";

interface RateLimitBucket {
  count: number;
  resetAt: number;
}

const buckets = new Map<string, Map<string, RateLimitBucket>>();

setInterval(() => {
  const now = Date.now();
  buckets.forEach((limiterMap) => {
    limiterMap.forEach((bucket, key) => {
      if (now > bucket.resetAt) limiterMap.delete(key);
    });
  });
}, 60 * 1000);

export function createRateLimiter(options: {
  name: string;
  maxRequests: number;
  windowMs: number;
  keyFn?: (req: Request) => string;
}) {
  const { name, maxRequests, windowMs } = options;
  const keyFn = options.keyFn || ((req: Request) => req.ip || "unknown");

  if (!buckets.has(name)) {
    buckets.set(name, new Map());
  }
  const limiterMap = buckets.get(name)!;

  return (req: Request, res: Response, next: NextFunction) => {
    const key = keyFn(req);
    const now = Date.now();
    const bucket = limiterMap.get(key);

    if (bucket && now < bucket.resetAt) {
      if (bucket.count >= maxRequests) {
        res.status(429).json({ error: "Too many requests. Please try again later." });
        return;
      }
      bucket.count++;
    } else {
      limiterMap.set(key, { count: 1, resetAt: now + windowMs });
    }

    next();
  };
}


============================================================
FILE: server/reddit-monitor.ts (309 lines)
============================================================
import Parser from "rss-parser";
import { db } from "./db";
import { businesses, campaigns, leads, aiResponses } from "@shared/schema";
import { eq } from "drizzle-orm";
import { sendTelegramMessage, sendTelegramMessageToChat } from "./telegram";
import { isRedditConfigured } from "./reddit-poster";
import { generateContent, parseAIJsonWithRetry, leadScoreSchema, TONE_MAP, MIN_MONITOR_INTENT_SCORE } from "./utils/ai";
import { escapeHtml } from "./utils/html";
import { hasBeenSeen, markSeen } from "./utils/dedup";
import { getFeedbackGuidance } from "./utils/feedback";
import { keywordMatch } from "./utils/keywords";

const parser = new Parser({
  headers: {
    "User-Agent": "Mozilla/5.0 (compatible; Gemin-Eye/1.0; +https://gemin-eye.com)",
    "Accept": "text/xml, application/rss+xml, application/xml",
  },
  timeout: 10000,
});
const SCAN_INTERVAL = 5 * 60 * 1000;
let monitorInterval: ReturnType<typeof setInterval> | null = null;

interface SubredditTarget {
  subreddit: string;
  businessId: number;
  businessName: string;
  businessType: string;
  coreOffering: string;
  preferredTone: string;
  campaignId: number;
  keywords: string[];
  ownerUserId: string;
}

async function getRedditTargets(): Promise<SubredditTarget[]> {
  const allBiz = await db.select().from(businesses);
  const allCamps = await db.select().from(campaigns);

  const targets: SubredditTarget[] = [];

  for (const biz of allBiz) {
    const bizCamps = allCamps.filter(
      (c) => c.businessId === biz.id && c.status === "active"
    );

    for (const camp of bizCamps) {
      const groups = (camp.targetGroups || []) as string[];
      const keywords = (camp.keywords || []) as string[];

      for (const group of groups) {
        const cleaned = group
          .replace(/^r\//, "")
          .replace(/^\/r\//, "")
          .trim();
        if (!cleaned) continue;
        if (/\s/.test(cleaned)) continue;
        if (cleaned.length > 50) continue;

        targets.push({
          subreddit: cleaned,
          businessId: biz.id,
          businessName: biz.name,
          businessType: biz.type,
          coreOffering: biz.coreOffering,
          preferredTone: biz.preferredTone,
          campaignId: camp.id,
          keywords,
          ownerUserId: biz.userId,
        });
      }
    }
  }

  return targets;
}

async function processPostForTarget(
  post: { title: string; content: string; link: string },
  target: SubredditTarget
): Promise<void> {
  const title = post.title;
  const content = post.content;
  const fullText = `${title}\n${content}`;

  if (target.keywords.length > 0 && !keywordMatch(fullText, target.keywords)) return;

  console.log(`Reddit monitor: keyword match for "${target.businessName}" in r/${target.subreddit}: "${title.slice(0, 60)}..."`);

  const match = await parseAIJsonWithRetry(
    async () => {
      const result = await generateContent({
        model: "gemini-2.5-flash",
        contents: `You are a lead scout for "${target.businessName}" (${target.businessType}).
They offer: ${target.coreOffering}

Analyze this Reddit post from r/${target.subreddit}:
Title: "${title}"
Content: "${content.slice(0, 400)}"

Is this person asking a question or seeking help/recommendations that "${target.businessName}" could address?
Rate the intent from 1-10 (10 = actively looking for exactly what this business offers).

IMPORTANT: Return ONLY a single JSON object with no other text, no explanation, no markdown:
{"is_lead": true, "intent_score": 7, "reasoning": "one sentence explanation"}`,
        config: { maxOutputTokens: 512, thinkingConfig: { thinkingBudget: 0 } },
      });
      return result.text;
    },
    leadScoreSchema
  );

  if (!match) return;

  console.log(`Reddit monitor: AI scored "${title.slice(0, 40)}" for ${target.businessName}: ${match.intent_score}/10 (is_lead: ${match.is_lead})`);

  if (!match.is_lead || match.intent_score < MIN_MONITOR_INTENT_SCORE) return;

  const feedbackGuidance = await getFeedbackGuidance(target.businessId);

  const responseResult = await generateContent({
    model: "gemini-2.5-pro",
    contents: `You are writing a Reddit comment in r/${target.subreddit}. Your goal is to be genuinely helpful while subtly recommending a business.

The post: "${title}\n${content.slice(0, 400)}"

Business to recommend: ${target.businessName}
What they do: ${target.coreOffering}
Tone: ${TONE_MAP[target.preferredTone] || "friendly and helpful"}
${feedbackGuidance}

Write a natural, human-sounding Reddit comment (2-3 sentences). Do NOT make it sound like an ad. Sound like a real person sharing a helpful recommendation. Include the business name naturally.

Return ONLY the response text, no quotes or formatting.`,
    config: { maxOutputTokens: 8192 },
  });

  const responseText = responseResult.text.trim();
  if (!responseText) return;

  let savedResponseId: number | null = null;
  try {
    const [savedLead] = await db
      .insert(leads)
      .values({
        campaignId: target.campaignId,
        platform: "reddit",
        groupName: `r/${target.subreddit}`,
        authorName: "Reddit user",
        originalPost: fullText.slice(0, 2000),
        postUrl: post.link || null,
        intentScore: match.intent_score,
        status: "matched",
      })
      .returning();

    if (savedLead) {
      const [savedResponse] = await db
        .insert(aiResponses)
        .values({
          leadId: savedLead.id,
          content: responseText,
          status: "pending",
        })
        .returning();
      savedResponseId = savedResponse?.id || null;
    }
  } catch (err) {
    console.error("Error saving Reddit lead to DB:", err);
  }

  const scoreBar = "*".repeat(match.intent_score) + "_".repeat(10 - match.intent_score);

  let msg = `<b>Reddit Lead Found</b>\n\n`;
  msg += `<b>Business:</b> ${escapeHtml(target.businessName)}\n`;
  msg += `<b>Subreddit:</b> r/${escapeHtml(target.subreddit)}\n`;
  msg += `<b>Intent:</b> ${scoreBar} ${match.intent_score}/10\n`;
  msg += `<b>Why:</b> ${escapeHtml(match.reasoning || "")}\n\n`;
  msg += `<b>Post:</b>\n<i>"${escapeHtml(title.slice(0, 200))}"</i>`;

  const buttons = [];
  if (post.link) {
    buttons.push([{ text: "Open Post", url: post.link }]);
  }
  if (savedResponseId && post.link && isRedditConfigured()) {
    buttons.push([{ text: "Post to Reddit", callback_data: `reddit_post_${savedResponseId}` }]);
  }
  if (savedResponseId) {
    buttons.push([
      { text: "Used It", callback_data: `fb_good_${savedResponseId}` },
      { text: "Bad Match", callback_data: `fb_bad_${savedResponseId}` },
      { text: "Too Salesy", callback_data: `fb_salesy_${savedResponseId}` },
      { text: "Wrong Client", callback_data: `fb_wrong_${savedResponseId}` },
    ]);
  }

  if (target.ownerUserId.startsWith("tg-")) {
    const clientChatId = target.ownerUserId.replace("tg-", "");
    await sendTelegramMessageToChat(clientChatId, msg, { buttons });
    await sendTelegramMessageToChat(clientChatId, responseText);
  } else {
    await sendTelegramMessage(msg, { buttons });
    await sendTelegramMessage(responseText);
  }
}

async function scanSubredditForTargets(subreddit: string, targets: SubredditTarget[]): Promise<void> {
  const url = `https://www.reddit.com/r/${subreddit}/new.rss`;

  try {
    const res = await fetch(url, {
      headers: {
        "User-Agent": "Gemin-Eye/1.0 (RSS Reader)",
        "Accept": "text/xml, application/rss+xml, application/xml",
      },
    });

    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }

    const xml = await res.text();
    const feed = await parser.parseString(xml);
    const posts = feed.items.slice(0, 5).map((item) => ({
      title: item.title || "",
      content: item.contentSnippet || item.content || "",
      link: item.link || "",
    }));

    let newPosts = 0;
    let kwMatches = 0;
    for (const post of posts) {
      const postId = post.link || post.title || "";
      if (!postId) continue;

      for (const target of targets) {
        const seenKey = `rd::${postId}::${target.businessId}`;
        if (await hasBeenSeen(seenKey)) continue;
        await markSeen(seenKey, "reddit");
        newPosts++;

        try {
          await processPostForTarget(post, target);
        } catch (err: any) {
          console.error(`Error processing post for ${target.businessName}: ${err?.message || err}`);
        }
      }
    }
    if (newPosts > 0) {
      console.log(`Reddit monitor: r/${subreddit} - ${posts.length} posts, ${newPosts} new evaluations`);
    }
  } catch (err: any) {
    const errMsg = err?.message || String(err);
    if (errMsg.includes("403") || errMsg.includes("429") || errMsg.includes("Forbidden")) {
      console.log(`Reddit rate-limited on r/${subreddit}, will retry next cycle`);
    } else if (errMsg.includes("404") || errMsg.includes("Not Found")) {
      console.log(`r/${subreddit} not found (invalid subreddit name), skipping`);
    } else {
      console.error(`Error scanning r/${subreddit}: ${errMsg}`);
    }
  }
}

async function runScan(): Promise<void> {
  const targets = await getRedditTargets();

  if (targets.length === 0) {
    return;
  }

  const subMap = new Map<string, SubredditTarget[]>();
  for (const t of targets) {
    const key = t.subreddit.toLowerCase();
    if (!subMap.has(key)) subMap.set(key, []);
    subMap.get(key)!.push(t);
  }

  console.log(`Reddit monitor: scanning ${subMap.size} subreddits for ${targets.length} business targets...`);

  const entries = Array.from(subMap.values());
  let scannedCount = 0;
  for (const subTargets of entries) {
    await scanSubredditForTargets(subTargets[0].subreddit, subTargets);
    scannedCount++;
    await new Promise((r) => setTimeout(r, 5000));
  }
  console.log(`Reddit monitor: scan complete (${scannedCount}/${subMap.size} subreddits)`);
}

export function startRedditMonitor(): void {
  if (monitorInterval) return;

  console.log("Reddit monitor: starting (scans every 5 minutes)");

  setTimeout(() => {
    runScan().catch((err) => console.error("Reddit monitor scan error:", err));
  }, 10000);

  monitorInterval = setInterval(() => {
    runScan().catch((err) => console.error("Reddit monitor scan error:", err));
  }, SCAN_INTERVAL);
}

export function stopRedditMonitor(): void {
  if (monitorInterval) {
    clearInterval(monitorInterval);
    monitorInterval = null;
    console.log("Reddit monitor: stopped");
  }
}


============================================================
FILE: server/reddit-poster.ts (107 lines)
============================================================
import Snoowrap from "snoowrap";

let redditClient: Snoowrap | null = null;

function getRedditClient(): Snoowrap | null {
  if (redditClient) return redditClient;

  const clientId = process.env.REDDIT_CLIENT_ID;
  const clientSecret = process.env.REDDIT_CLIENT_SECRET;
  const username = process.env.REDDIT_USERNAME;
  const password = process.env.REDDIT_PASSWORD;

  if (!clientId || !clientSecret || !username || !password) {
    return null;
  }

  redditClient = new Snoowrap({
    userAgent: "Gemin-Eye/1.0 (by /u/" + username + ")",
    clientId,
    clientSecret,
    username,
    password,
  });

  redditClient.config({ requestDelay: 1000, continueAfterRatelimitError: true });

  return redditClient;
}

export function isRedditConfigured(): boolean {
  return !!(
    process.env.REDDIT_CLIENT_ID &&
    process.env.REDDIT_CLIENT_SECRET &&
    process.env.REDDIT_USERNAME &&
    process.env.REDDIT_PASSWORD
  );
}

export async function postRedditComment(postUrl: string, commentText: string): Promise<{ success: boolean; commentUrl?: string; error?: string }> {
  const client = getRedditClient();
  if (!client) {
    return { success: false, error: "Reddit credentials not configured. Add REDDIT_CLIENT_ID, REDDIT_CLIENT_SECRET, REDDIT_USERNAME, and REDDIT_PASSWORD." };
  }

  try {
    const postId = extractPostId(postUrl);
    if (!postId) {
      return { success: false, error: "Could not extract Reddit post ID from URL: " + postUrl };
    }

    const submission = client.getSubmission(postId);
    const comment: any = await (submission as any).reply(commentText);
    const commentUrl = `https://www.reddit.com${comment.permalink || ""}`;

    return { success: true, commentUrl };
  } catch (error: any) {
    console.error("Reddit post error:", error);
    const msg = error?.message || String(error);
    if (msg.includes("RATELIMIT") || msg.includes("rate limit")) {
      return { success: false, error: "Reddit rate limit hit. Wait a few minutes and try again." };
    }
    if (msg.includes("403") || msg.includes("Forbidden")) {
      return { success: false, error: "Reddit credentials invalid or account lacks permission." };
    }
    return { success: false, error: "Reddit API error: " + msg.slice(0, 200) };
  }
}

export async function postRedditSubmission(subreddit: string, title: string, body: string): Promise<{ success: boolean; postUrl?: string; error?: string }> {
  const client = getRedditClient();
  if (!client) {
    return { success: false, error: "Reddit credentials not configured. Add REDDIT_CLIENT_ID, REDDIT_CLIENT_SECRET, REDDIT_USERNAME, and REDDIT_PASSWORD." };
  }

  try {
    const sub = subreddit.replace(/^r\//, "");
    const submission: any = await (client.getSubreddit(sub) as any).submitSelfpost({ title, text: body });
    const postUrl = `https://www.reddit.com${submission.permalink || ""}`;

    return { success: true, postUrl };
  } catch (error: any) {
    console.error("Reddit submission error:", error);
    const msg = error?.message || String(error);
    if (msg.includes("RATELIMIT") || msg.includes("rate limit")) {
      return { success: false, error: "Reddit rate limit hit. Wait a few minutes and try again." };
    }
    if (msg.includes("SUBREDDIT_NOEXIST")) {
      return { success: false, error: "That subreddit doesn't exist." };
    }
    return { success: false, error: "Reddit API error: " + msg.slice(0, 200) };
  }
}

function extractPostId(url: string): string | null {
  const patterns = [
    /reddit\.com\/r\/\w+\/comments\/([a-z0-9]+)/i,
    /redd\.it\/([a-z0-9]+)/i,
    /reddit\.com\/comments\/([a-z0-9]+)/i,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }

  return null;
}


============================================================
FILE: server/google-alerts-monitor.ts (314 lines)
============================================================
import Parser from "rss-parser";
import { db } from "./db";
import { businesses, campaigns, leads, aiResponses } from "@shared/schema";
import { eq } from "drizzle-orm";
import { sendTelegramMessage, sendTelegramMessageToChat } from "./telegram";
import { isRedditConfigured } from "./reddit-poster";
import { generateContent, parseAIJsonWithRetry, leadScoreSchema, TONE_MAP, MIN_MONITOR_INTENT_SCORE } from "./utils/ai";
import { escapeHtml, stripHtml, canonicalizeUrl } from "./utils/html";
import { hasBeenSeen, markSeen } from "./utils/dedup";
import { getFeedbackGuidance } from "./utils/feedback";
import { keywordMatch } from "./utils/keywords";

const parser = new Parser({
  headers: {
    "User-Agent": "Mozilla/5.0 (compatible; Gemin-Eye/1.0; +https://gemin-eye.com)",
    "Accept": "text/xml, application/rss+xml, application/xml, application/atom+xml",
  },
  timeout: 15000,
});

const SCAN_INTERVAL = 120 * 1000;
let monitorInterval: ReturnType<typeof setInterval> | null = null;

interface AlertTarget {
  feedUrl: string;
  businessId: number;
  businessName: string;
  businessType: string;
  coreOffering: string;
  preferredTone: string;
  campaignId: number;
  keywords: string[];
  ownerUserId: string;
}

async function getAlertTargets(): Promise<AlertTarget[]> {
  const allBiz = await db.select().from(businesses);
  const allCamps = await db.select().from(campaigns);

  const targets: AlertTarget[] = [];

  for (const biz of allBiz) {
    const bizCamps = allCamps.filter(
      (c) => c.businessId === biz.id && c.status === "active" && c.platform.toLowerCase() === "google_alerts"
    );

    for (const camp of bizCamps) {
      const feedUrls = (camp.targetGroups || []) as string[];
      const keywords = (camp.keywords || []) as string[];

      for (const feedUrl of feedUrls) {
        const trimmed = feedUrl.trim();
        if (!trimmed) continue;
        if (!trimmed.startsWith("http")) continue;

        targets.push({
          feedUrl: trimmed,
          businessId: biz.id,
          businessName: biz.name,
          businessType: biz.type,
          coreOffering: biz.coreOffering,
          preferredTone: biz.preferredTone,
          campaignId: camp.id,
          keywords,
          ownerUserId: biz.userId,
        });
      }
    }
  }

  return targets;
}

function extractSourceName(link: string): string {
  try {
    const url = new URL(link);
    const host = url.hostname.replace("www.", "");
    if (host.includes("quora.com")) return "Quora";
    if (host.includes("reddit.com")) return "Reddit";
    if (host.includes("stackoverflow.com")) return "Stack Overflow";
    if (host.includes("youtube.com")) return "YouTube";
    if (host.includes("medium.com")) return "Medium";
    return host;
  } catch {
    return "Web";
  }
}

async function processAlertItem(
  item: { title: string; content: string; link: string; source: string },
  target: AlertTarget
): Promise<void> {
  const fullText = `${item.title}\n${item.content}`;

  if (!keywordMatch(fullText, target.keywords)) return;

  const match = await parseAIJsonWithRetry(
    async () => {
      const result = await generateContent({
        model: "gemini-2.5-flash",
        contents: `You are a lead scout for "${target.businessName}" (${target.businessType}).
They offer: ${target.coreOffering}

Analyze this web content found via Google Alerts:
Source: ${item.source}
Title: "${item.title}"
Content: "${item.content.slice(0, 600)}"

Is this person asking a question or seeking help/recommendations that "${target.businessName}" could address?
Rate the intent from 1-10 (10 = actively looking for exactly what this business offers).

IMPORTANT: Return ONLY a single JSON object with no other text, no explanation, no markdown:
{"is_lead": true, "intent_score": 7, "reasoning": "one sentence explanation"}`,
        config: { maxOutputTokens: 512, thinkingConfig: { thinkingBudget: 0 } },
      });
      return result.text;
    },
    leadScoreSchema
  );

  if (!match) return;

  if (!match.is_lead || match.intent_score < MIN_MONITOR_INTENT_SCORE) return;

  const feedbackGuidance = await getFeedbackGuidance(target.businessId);

  const platformLabel = item.source === "Quora" ? "Quora answer" :
    item.source === "Reddit" ? "Reddit comment" :
    item.source === "YouTube" ? "YouTube comment" :
    `${item.source} comment/reply`;

  const responseResult = await generateContent({
    model: "gemini-2.5-pro",
    contents: `You are writing a ${platformLabel}. Your goal is to be genuinely helpful while subtly recommending a business.

The post/question: "${item.title}\n${item.content.slice(0, 600)}"

Business to recommend: ${target.businessName}
What they do: ${target.coreOffering}
Tone: ${TONE_MAP[target.preferredTone] || "friendly and helpful"}
${feedbackGuidance}

Write a natural, human-sounding response (2-3 sentences). Do NOT make it sound like an ad. Sound like a real person sharing a helpful recommendation. Include the business name naturally.

Return ONLY the response text, no quotes or formatting.`,
    config: { maxOutputTokens: 8192 },
  });

  const responseText = responseResult.text.trim();
  if (!responseText) return;

  let savedResponseId: number | null = null;
  try {
    const [savedLead] = await db
      .insert(leads)
      .values({
        campaignId: target.campaignId,
        platform: "google_alerts",
        groupName: item.source,
        authorName: "Web user",
        originalPost: fullText.slice(0, 2000),
        postUrl: item.link || null,
        intentScore: match.intent_score,
        status: "matched",
      })
      .returning();

    if (savedLead) {
      const [savedResponse] = await db
        .insert(aiResponses)
        .values({
          leadId: savedLead.id,
          content: responseText,
          status: "pending",
        })
        .returning();
      savedResponseId = savedResponse?.id || null;
    }
  } catch (err) {
    console.error("Error saving Google Alert lead to DB:", err);
  }

  const scoreBar = "*".repeat(match.intent_score) + "_".repeat(10 - match.intent_score);

  let msg = `<b>Google Alert Lead Found</b>\n\n`;
  msg += `<b>Business:</b> ${escapeHtml(target.businessName)}\n`;
  msg += `<b>Source:</b> ${escapeHtml(item.source)}\n`;
  msg += `<b>Intent:</b> ${scoreBar} ${match.intent_score}/10\n`;
  msg += `<b>Why:</b> ${escapeHtml(match.reasoning || "")}\n\n`;
  msg += `<b>Post:</b>\n<i>"${escapeHtml(item.title.slice(0, 200))}"</i>`;

  if (item.link) {
    msg += `\n\nTap "Open Page" below, then paste the reply.`;
  }

  const buttons: Array<Array<{ text: string; url?: string; callback_data?: string }>> = [];
  if (item.link) {
    buttons.push([{ text: "Open Page", url: item.link }]);
  }
  const isRedditSource = item.link && /reddit\.com\/r\/\w+\/comments\//i.test(item.link);
  if (savedResponseId && isRedditSource && isRedditConfigured()) {
    buttons.push([{ text: "Post to Reddit", callback_data: `reddit_post_${savedResponseId}` }]);
  }
  if (savedResponseId) {
    buttons.push([
      { text: "Used It", callback_data: `fb_good_${savedResponseId}` },
      { text: "Bad Match", callback_data: `fb_bad_${savedResponseId}` },
      { text: "Too Salesy", callback_data: `fb_salesy_${savedResponseId}` },
      { text: "Wrong Client", callback_data: `fb_wrong_${savedResponseId}` },
    ]);
  }

  if (target.ownerUserId.startsWith("tg-")) {
    const clientChatId = target.ownerUserId.replace("tg-", "");
    await sendTelegramMessageToChat(clientChatId, msg, buttons.length > 0 ? { buttons } : undefined);
    await sendTelegramMessageToChat(clientChatId, responseText);
  } else {
    await sendTelegramMessage(msg, buttons.length > 0 ? { buttons } : undefined);
    await sendTelegramMessage(responseText);
  }
}

async function scanFeedForTargets(feedUrl: string, targets: AlertTarget[]): Promise<void> {
  try {
    const res = await fetch(feedUrl, {
      headers: {
        "User-Agent": "Gemin-Eye/1.0 (RSS Reader)",
        "Accept": "text/xml, application/rss+xml, application/xml, application/atom+xml",
      },
    });

    if (!res.ok) {
      throw new Error(`HTTP ${res.status}`);
    }

    const xml = await res.text();
    const feed = await parser.parseString(xml);
    const items = feed.items.slice(0, 8).map((item) => ({
      title: item.title ? stripHtml(item.title) : "",
      content: stripHtml(item.contentSnippet || item.content || item.summary || ""),
      link: item.link || "",
      source: item.link ? extractSourceName(item.link) : "Web",
    }));

    for (const item of items) {
      const itemId = item.link ? canonicalizeUrl(item.link) : (item.title || "");
      if (!itemId) continue;

      for (const target of targets) {
        const seenKey = `ga::${itemId}::${target.businessId}`;
        if (await hasBeenSeen(seenKey)) continue;
        await markSeen(seenKey, "google_alerts");

        try {
          await processAlertItem(item, target);
        } catch (err: any) {
          console.error(`Error processing alert for ${target.businessName}: ${err?.message || err}`);
        }
      }
    }
  } catch (err: any) {
    const errMsg = err?.message || String(err);
    if (errMsg.includes("403") || errMsg.includes("429")) {
      console.log(`Google Alerts rate-limited for feed, will retry next cycle`);
    } else {
      console.error(`Error scanning Google Alert feed: ${errMsg}`);
    }
  }
}

async function runScan(): Promise<void> {
  const targets = await getAlertTargets();

  if (targets.length === 0) {
    return;
  }

  const feedMap = new Map<string, AlertTarget[]>();
  for (const t of targets) {
    const key = t.feedUrl;
    if (!feedMap.has(key)) feedMap.set(key, []);
    feedMap.get(key)!.push(t);
  }

  console.log(`Google Alerts monitor: scanning ${feedMap.size} feeds for ${targets.length} business targets...`);

  const entries = Array.from(feedMap.values());
  for (const feedTargets of entries) {
    await scanFeedForTargets(feedTargets[0].feedUrl, feedTargets);
    await new Promise((r) => setTimeout(r, 3000));
  }
}

export function startGoogleAlertsMonitor(): void {
  if (monitorInterval) return;

  console.log("Google Alerts monitor: starting (scans every 2 minutes)");

  setTimeout(() => {
    runScan().catch((err) => console.error("Google Alerts monitor scan error:", err));
  }, 15000);

  monitorInterval = setInterval(() => {
    runScan().catch((err) => console.error("Google Alerts monitor scan error:", err));
  }, SCAN_INTERVAL);
}

export function stopGoogleAlertsMonitor(): void {
  if (monitorInterval) {
    clearInterval(monitorInterval);
    monitorInterval = null;
    console.log("Google Alerts monitor: stopped");
  }
}


============================================================
FILE: client/src/App.tsx (46 lines)
============================================================
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { ThemeProvider } from "@/components/theme-provider";
import { useAuth } from "@/hooks/use-auth";
import LandingPage from "@/pages/landing";
import Dashboard from "@/pages/dashboard";
import OnboardingPage from "@/pages/onboarding";
import NotFound from "@/pages/not-found";
import ClientGuidePage from "@/pages/client-guide";
import AdminPage from "@/pages/admin";

function AuthRouter() {
  const { user, isLoading } = useAuth();

  if (isLoading) {
    return null;
  }

  return (
    <Switch>
      <Route path="/" component={user ? Dashboard : LandingPage} />
      <Route path="/onboarding" component={OnboardingPage} />
      <Route path="/guide" component={ClientGuidePage} />
      <Route path="/admin" component={AdminPage} />
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>
        <TooltipProvider>
          <Toaster />
          <AuthRouter />
        </TooltipProvider>
      </ThemeProvider>
    </QueryClientProvider>
  );
}

export default App;


============================================================
FILE: client/src/pages/landing.tsx (349 lines)
============================================================
import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Eye, Target, MessageCircle, Shield, ArrowRight, Zap, Users, Bot, Send, Quote, Globe, Utensils, Brain, Dog, Dumbbell, ExternalLink } from "lucide-react";
import { SiFacebook, SiReddit, SiLinkedin, SiGoogle } from "react-icons/si";
import { useTheme } from "@/components/theme-provider";

const demoPost = {
  author: "Sarah M.",
  group: "West Suburbs Community",
  text: "Hey everyone, looking for a reliable estate planning lawyer in the West Suburbs. Any recommendations?",
};

const demoResponse = "Hi Sarah! A friend of mine recently worked with Mitchell & Associates on their estate plan and had a wonderful experience. They're based right in Brookfield and really take the time to explain everything. Might be worth giving them a call!";

function TypingAnimation({ text, onComplete }: { text: string; onComplete?: () => void }) {
  const [displayed, setDisplayed] = useState("");
  const [index, setIndex] = useState(0);

  useEffect(() => {
    if (index < text.length) {
      const timer = setTimeout(() => {
        setDisplayed((prev) => prev + text[index]);
        setIndex((prev) => prev + 1);
      }, 18);
      return () => clearTimeout(timer);
    } else {
      onComplete?.();
    }
  }, [index, text, onComplete]);

  return (
    <span>
      {displayed}
      {index < text.length && (
        <span className="inline-block w-0.5 h-4 bg-primary ml-0.5 animate-pulse" />
      )}
    </span>
  );
}

function DemoPreview() {
  const [stage, setStage] = useState<"post" | "thinking" | "response">("post");

  useEffect(() => {
    const t1 = setTimeout(() => setStage("thinking"), 2500);
    const t2 = setTimeout(() => setStage("response"), 4500);
    return () => {
      clearTimeout(t1);
      clearTimeout(t2);
    };
  }, []);

  return (
    <div className="relative">
      <Card className="p-5 space-y-4">
        <div className="flex items-center gap-3">
          <div className="w-9 h-9 rounded-full bg-primary/20 flex items-center justify-center">
            <Users className="w-4 h-4 text-primary" />
          </div>
          <div>
            <p className="text-sm font-medium" data-testid="text-demo-author">{demoPost.author}</p>
            <p className="text-xs text-muted-foreground">{demoPost.group}</p>
          </div>
        </div>
        <p className="text-sm leading-relaxed text-foreground/90" data-testid="text-demo-post">
          "{demoPost.text}"
        </p>

        {stage === "thinking" && (
          <div className="flex items-center gap-2 pt-2">
            <Bot className="w-4 h-4 text-primary animate-pulse" />
            <span className="text-xs text-primary font-medium">AI Agent Thinking...</span>
            <div className="flex gap-1">
              <span className="w-1.5 h-1.5 rounded-full bg-primary animate-bounce" style={{ animationDelay: "0ms" }} />
              <span className="w-1.5 h-1.5 rounded-full bg-primary animate-bounce" style={{ animationDelay: "150ms" }} />
              <span className="w-1.5 h-1.5 rounded-full bg-primary animate-bounce" style={{ animationDelay: "300ms" }} />
            </div>
          </div>
        )}

        {stage === "response" && (
          <div className="border-t pt-4 space-y-2">
            <div className="flex items-center gap-2">
              <div className="w-7 h-7 rounded-full bg-chart-2/20 flex items-center justify-center">
                <Send className="w-3 h-3 text-chart-2" />
              </div>
              <span className="text-xs font-medium text-chart-2">Gemin-Eye Response</span>
            </div>
            <p className="text-sm leading-relaxed text-foreground/80" data-testid="text-demo-response">
              <TypingAnimation text={demoResponse} />
            </p>
          </div>
        )}
      </Card>
      <div className="absolute -top-3 -right-3">
        <Badge variant="secondary" className="text-xs">Live Demo</Badge>
      </div>
    </div>
  );
}

export default function LandingPage() {
  const { theme, toggleTheme } = useTheme();

  const features = [
    {
      icon: Target,
      title: "Hyper-Targeted",
      description: "We find the exact people asking for your service right now. No wasted impressions.",
      color: "text-primary",
      bg: "bg-primary/10",
    },
    {
      icon: MessageCircle,
      title: "Subtle & Human",
      description: "Our AI crafts responses that look like friendly advice, not disruptive ads.",
      color: "text-chart-2",
      bg: "bg-chart-2/10",
    },
    {
      icon: Shield,
      title: "Trusted Channels",
      description: "By participating in niche groups, your brand leverages built-in community trust.",
      color: "text-chart-3",
      bg: "bg-chart-3/10",
    },
  ];

  const howItWorks = [
    {
      step: "01",
      title: "Describe Your Business",
      description: "Tell us who you are, what you offer, and who your ideal customer is.",
      icon: Users,
    },
    {
      step: "02",
      title: "AI Generates Your Strategy",
      description: "Our top-tier AI analyzes your business and identifies the best groups, keywords, and platforms to target.",
      icon: Bot,
    },
    {
      step: "03",
      title: "Monitor & Respond",
      description: "Gemin-Eye watches for high-intent posts and crafts human-like responses. You approve and post in seconds via Telegram alerts.",
      icon: Zap,
    },
  ];

  return (
    <div className="min-h-screen bg-background">
      <nav className="fixed top-0 left-0 right-0 z-50 backdrop-blur-xl bg-background/80 border-b">
        <div className="max-w-6xl mx-auto px-4 sm:px-6 h-16 flex items-center justify-between gap-4">
          <div className="flex items-center gap-2">
            <img src="/images/logo.png" alt="Gemin-Eye" className="w-7 h-7" />
            <span className="font-semibold text-lg tracking-tight" data-testid="text-brand-name">Gemin-Eye</span>
          </div>
          <div className="hidden md:flex items-center gap-6">
            <a href="#features" className="text-sm text-muted-foreground hover:text-foreground transition-colors">Features</a>
            <a href="#how-it-works" className="text-sm text-muted-foreground hover:text-foreground transition-colors">How It Works</a>
            <a href="#clients" className="text-sm text-muted-foreground hover:text-foreground transition-colors" data-testid="link-nav-clients">Clients</a>
          </div>
          <div className="flex items-center gap-3">
            <Button variant="ghost" size="sm" asChild data-testid="button-login">
              <a href="/api/login">Log In</a>
            </Button>
            <Button size="sm" asChild data-testid="button-get-started">
              <a href="/api/login">Get Started <ArrowRight className="w-4 h-4 ml-1" /></a>
            </Button>
          </div>
        </div>
      </nav>

      <section className="pt-32 pb-20 px-4 sm:px-6">
        <div className="max-w-6xl mx-auto grid lg:grid-cols-2 gap-12 lg:gap-16 items-center">
          <div className="space-y-6">
            <Badge variant="secondary" className="text-xs" data-testid="badge-tagline">
              <Zap className="w-3 h-3 mr-1" /> AI-Powered Customer Acquisition
            </Badge>
            <h1 className="text-4xl sm:text-5xl lg:text-6xl font-serif font-bold leading-tight tracking-tight" data-testid="text-hero-title">
              Customer Acquisition,{" "}
              <span className="text-primary">Reimagined.</span>
            </h1>
            <p className="text-lg text-muted-foreground max-w-lg leading-relaxed" data-testid="text-hero-subtitle">
              Stop blasting ads to millions. Gemin-Eye monitors specific interest groups and responds to high-intent questions as a helpful human.
            </p>
            <div className="flex flex-wrap items-center gap-3">
              <Button size="lg" asChild data-testid="button-hero-cta">
                <a href="/api/login">
                  Get Started Free <ArrowRight className="w-4 h-4 ml-2" />
                </a>
              </Button>
              <Button variant="outline" size="lg" asChild data-testid="button-hero-demo">
                <a href="#how-it-works">View Demo</a>
              </Button>
            </div>
            <div className="flex items-center gap-4 pt-2">
              <div className="flex items-center gap-2.5">
                <SiFacebook className="w-4 h-4 text-muted-foreground" />
                <SiReddit className="w-4 h-4 text-muted-foreground" />
                <SiLinkedin className="w-4 h-4 text-muted-foreground" />
                <SiGoogle className="w-4 h-4 text-muted-foreground" />
              </div>
              <span className="text-xs text-muted-foreground">Monitors the internet for your next customer</span>
            </div>
          </div>

          <div className="lg:pl-8">
            <DemoPreview />
          </div>
        </div>
      </section>

      <section id="features" className="py-20 px-4 sm:px-6 bg-card/50">
        <div className="max-w-6xl mx-auto">
          <div className="text-center mb-14">
            <h2 className="text-3xl font-serif font-bold mb-3" data-testid="text-features-title">The Smartest Way to Sell</h2>
            <p className="text-muted-foreground max-w-md mx-auto">
              Direct, intentional response advertising that finds your customers where they're already asking.
            </p>
          </div>
          <div className="grid md:grid-cols-3 gap-6">
            {features.map((f) => (
              <Card key={f.title} className="p-6 space-y-4 hover-elevate" data-testid={`card-feature-${f.title.toLowerCase().replace(/\s+/g, "-")}`}>
                <div className={`w-10 h-10 rounded-md ${f.bg} flex items-center justify-center`}>
                  <f.icon className={`w-5 h-5 ${f.color}`} />
                </div>
                <h3 className="font-semibold text-lg">{f.title}</h3>
                <p className="text-sm text-muted-foreground leading-relaxed">{f.description}</p>
              </Card>
            ))}
          </div>
        </div>
      </section>

      <section id="how-it-works" className="py-20 px-4 sm:px-6">
        <div className="max-w-6xl mx-auto">
          <div className="text-center mb-14">
            <h2 className="text-3xl font-serif font-bold mb-3" data-testid="text-how-title">How It Works</h2>
            <p className="text-muted-foreground max-w-md mx-auto">
              From setup to your first lead in minutes, not months.
            </p>
          </div>
          <div className="grid md:grid-cols-3 gap-8">
            {howItWorks.map((step) => (
              <div key={step.step} className="text-center space-y-4" data-testid={`step-${step.step}`}>
                <div className="w-14 h-14 mx-auto rounded-full bg-primary/10 flex items-center justify-center">
                  <step.icon className="w-6 h-6 text-primary" />
                </div>
                <div className="text-xs font-mono text-primary font-semibold">STEP {step.step}</div>
                <h3 className="font-semibold text-lg">{step.title}</h3>
                <p className="text-sm text-muted-foreground leading-relaxed">{step.description}</p>
              </div>
            ))}
          </div>
        </div>
      </section>

      <section id="clients" className="py-20 px-4 sm:px-6 bg-card/50">
        <div className="max-w-6xl mx-auto">
          <div className="text-center mb-14">
            <h2 className="text-3xl font-serif font-bold mb-3" data-testid="text-clients-title">Trusted by Growing Businesses</h2>
            <p className="text-muted-foreground max-w-md mx-auto">
              From local restaurants to national breeders, businesses across industries use Gemin-Eye to find customers organically.
            </p>
          </div>
          <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-6 gap-4">
            {[
              { name: "Doro Mind", type: "Mental Health", icon: Brain, url: "https://doromind.com" },
              { name: "Chicago Bocce", type: "Recreation", icon: Dumbbell, url: "https://www.chicagobocceclub.com/" },
              { name: "LMAITFY.ai", type: "AI Tool", icon: Globe, url: "https://lmaitfy.ai" },
              { name: "Tony's", type: "Diner", icon: Utensils, url: "https://tonysofbrookfield.com/" },
              { name: "Heart of America Whoodles", type: "Dog Breeder", icon: Dog, url: "https://heartofamericawhoodles.com" },
              { name: "Gemin-Eye", type: "AI SaaS", icon: Eye, url: "https://gemin-eye.com" },
            ].map((client) => (
              <a key={client.name} href={client.url} target="_blank" rel="noopener noreferrer" data-testid={`link-client-${client.name.toLowerCase().replace(/\s+/g, "-")}`}>
                <Card className="p-4 flex flex-col items-center text-center gap-2 hover-elevate h-full" data-testid={`card-client-${client.name.toLowerCase().replace(/\s+/g, "-")}`}>
                  <div className="w-10 h-10 rounded-full bg-primary/10 flex items-center justify-center">
                    <client.icon className="w-5 h-5 text-primary" />
                  </div>
                  <p className="text-sm font-medium leading-tight" data-testid={`text-client-name-${client.name.toLowerCase().replace(/\s+/g, "-")}`}>{client.name}</p>
                  <p className="text-xs text-muted-foreground" data-testid={`text-client-type-${client.name.toLowerCase().replace(/\s+/g, "-")}`}>{client.type}</p>
                  <ExternalLink className="w-3 h-3 text-muted-foreground/50" />
                </Card>
              </a>
            ))}
          </div>
        </div>
      </section>

      <section className="py-20 px-4 sm:px-6">
        <div className="max-w-3xl mx-auto">
          <div className="text-center mb-10">
            <h2 className="text-3xl font-serif font-bold mb-3" data-testid="text-testimonial-title">We Eat Our Own Cooking</h2>
            <p className="text-muted-foreground max-w-md mx-auto">
              Gemin-Eye uses its own platform to find new clients. If that's not confidence in your product, what is?
            </p>
          </div>
          <Card className="p-8 relative" data-testid="card-testimonial">
            <Quote className="w-10 h-10 text-primary/20 absolute top-6 left-6" />
            <div className="relative space-y-4 pl-4">
              <p className="text-lg leading-relaxed text-foreground/90 italic" data-testid="text-testimonial-quote">
                "We built Gemin-Eye to help businesses find customers without ads or cold outreach. So naturally, we asked ourselves: why not use it to find our own clients? We set up Gemin-Eye as its own client — monitoring Reddit, Facebook Groups, and Google Alerts for entrepreneurs and marketers asking about lead generation, customer acquisition, and organic growth. It works. The same AI that finds dog-breed seekers and bocce enthusiasts also finds SaaS founders who need exactly what we built. We're client number seven, and we're our own best case study."
              </p>
              <div className="flex items-center gap-3 pt-2">
                <div className="w-10 h-10 rounded-full bg-primary flex items-center justify-center">
                  <Eye className="w-5 h-5 text-primary-foreground" />
                </div>
                <div>
                  <p className="font-semibold text-sm" data-testid="text-testimonial-author">Gemin-Eye Team</p>
                  <p className="text-xs text-muted-foreground" data-testid="text-testimonial-subtitle">Client #7 — Yes, we monitor ourselves</p>
                </div>
                <Badge variant="secondary" className="ml-auto text-xs" data-testid="badge-active-client">
                  <Zap className="w-3 h-3 mr-1" /> Active Client
                </Badge>
              </div>
            </div>
          </Card>
        </div>
      </section>

      <section className="py-20 px-4 sm:px-6 bg-card/50">
        <div className="max-w-2xl mx-auto text-center space-y-6">
          <h2 className="text-3xl font-serif font-bold" data-testid="text-cta-title">Ready to Find Your Next Customer?</h2>
          <p className="text-muted-foreground">
            Join businesses that are already using AI to turn community conversations into qualified leads.
          </p>
          <Button size="lg" asChild data-testid="button-cta-final">
            <a href="/api/login">
              Start For Free <ArrowRight className="w-4 h-4 ml-2" />
            </a>
          </Button>
        </div>
      </section>

      <footer className="border-t py-8 px-4 sm:px-6">
        <div className="max-w-6xl mx-auto flex flex-wrap items-center justify-between gap-4">
          <div className="flex items-center gap-2">
            <img src="/images/logo.png" alt="Gemin-Eye" className="w-5 h-5" />
            <span className="text-sm font-medium">Gemin-Eye</span>
          </div>
          <p className="text-xs text-muted-foreground">&copy; 2026 Gemin-Eye. All rights reserved.</p>
        </div>
      </footer>
    </div>
  );
}


============================================================
FILE: client/src/pages/dashboard.tsx (339 lines)
============================================================
import { useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import { useLocation } from "wouter";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  Eye, Target, MessageCircle, TrendingUp, Copy, ExternalLink,
  CheckCircle, Clock, AlertCircle, Zap, ArrowRight, LogOut, Plus, Users, Send, Settings
} from "lucide-react";
import { useMutation } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import type { Business, Campaign, Lead, AiResponse } from "@shared/schema";

function StatCard({ title, value, icon: Icon, trend, color }: {
  title: string; value: string | number; icon: any; trend?: string; color: string;
}) {
  return (
    <Card className="p-5 space-y-3" data-testid={`stat-${title.toLowerCase().replace(/\s+/g, "-")}`}>
      <div className="flex items-center justify-between gap-4">
        <span className="text-sm text-muted-foreground">{title}</span>
        <div className={`w-9 h-9 rounded-md ${color} flex items-center justify-center`}>
          <Icon className="w-4 h-4" />
        </div>
      </div>
      <div className="flex items-end justify-between gap-4">
        <span className="text-2xl font-bold">{value}</span>
        {trend && (
          <span className="text-xs text-chart-2 flex items-center gap-1">
            <TrendingUp className="w-3 h-3" /> {trend}
          </span>
        )}
      </div>
    </Card>
  );
}

function LeadCard({ lead, response }: { lead: Lead; response?: AiResponse }) {
  const { toast } = useToast();

  const statusConfig: Record<string, { label: string; variant: "default" | "secondary" | "destructive"; icon: any }> = {
    new: { label: "New", variant: "default", icon: AlertCircle },
    responded: { label: "Responded", variant: "secondary", icon: CheckCircle },
    pending: { label: "Pending", variant: "secondary", icon: Clock },
  };

  const config = statusConfig[lead.status] || statusConfig.new;

  const handleCopy = () => {
    if (response) {
      navigator.clipboard.writeText(response.content);
      toast({ title: "Copied!", description: "Response copied to clipboard." });
    }
  };

  const sendToTelegram = useMutation({
    mutationFn: async () => {
      const res = await apiRequest("POST", "/api/telegram/notify-lead", { leadId: lead.id });
      return res.json();
    },
    onSuccess: () => {
      toast({ title: "Sent to Telegram", description: "Lead notification sent to your Telegram." });
    },
    onError: () => {
      toast({ title: "Failed", description: "Could not send to Telegram.", variant: "destructive" });
    },
  });

  return (
    <Card className="p-5 space-y-4" data-testid={`card-lead-${lead.id}`}>
      <div className="flex items-start justify-between gap-3">
        <div className="flex items-center gap-3 min-w-0">
          <div className="w-9 h-9 rounded-full bg-primary/10 flex-shrink-0 flex items-center justify-center">
            <MessageCircle className="w-4 h-4 text-primary" />
          </div>
          <div className="min-w-0">
            <p className="text-sm font-medium truncate">{lead.authorName}</p>
            <p className="text-xs text-muted-foreground truncate">{lead.groupName} &middot; {lead.platform}</p>
          </div>
        </div>
        <div className="flex items-center gap-2 flex-shrink-0">
          <Badge variant={config.variant} className="text-xs">
            <config.icon className="w-3 h-3 mr-1" />
            {config.label}
          </Badge>
          <Badge variant="secondary" className="text-xs">
            {lead.intentScore}/10
          </Badge>
        </div>
      </div>

      <p className="text-sm leading-relaxed bg-muted/50 p-3 rounded-md" data-testid={`text-lead-post-${lead.id}`}>
        "{lead.originalPost}"
      </p>

      {response && (
        <div className="space-y-2">
          <div className="flex items-center gap-2">
            <Zap className="w-3 h-3 text-chart-2" />
            <span className="text-xs font-medium text-chart-2">AI Response</span>
          </div>
          <p className="text-sm leading-relaxed text-muted-foreground" data-testid={`text-response-${lead.id}`}>
            {response.content}
          </p>
          <div className="flex flex-wrap items-center gap-2 pt-1">
            <Button variant="outline" size="sm" onClick={handleCopy} data-testid={`button-copy-${lead.id}`}>
              <Copy className="w-3 h-3 mr-1" /> Copy
            </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => sendToTelegram.mutate()}
              disabled={sendToTelegram.isPending}
              data-testid={`button-telegram-${lead.id}`}
            >
              <Send className="w-3 h-3 mr-1" /> {sendToTelegram.isPending ? "Sending..." : "Send to Telegram"}
            </Button>
            {lead.postUrl && (
              <Button variant="outline" size="sm" asChild data-testid={`button-link-${lead.id}`}>
                <a href={lead.postUrl} target="_blank" rel="noopener noreferrer">
                  <ExternalLink className="w-3 h-3 mr-1" /> Open Post
                </a>
              </Button>
            )}
          </div>
        </div>
      )}
    </Card>
  );
}

function CampaignCard({ campaign }: { campaign: Campaign }) {
  return (
    <Card className="p-5 space-y-3 hover-elevate" data-testid={`card-campaign-${campaign.id}`}>
      <div className="flex items-center justify-between gap-3">
        <h3 className="font-semibold truncate">{campaign.name}</h3>
        <Badge variant={campaign.status === "active" ? "default" : "secondary"} className="text-xs flex-shrink-0">
          {campaign.status}
        </Badge>
      </div>
      <div className="flex items-center gap-3">
        <Badge variant="secondary" className="text-xs">{campaign.platform}</Badge>
        <span className="text-xs text-muted-foreground">
          {(campaign.targetGroups as string[])?.length || 0} groups
        </span>
      </div>
      {campaign.keywords && (campaign.keywords as string[]).length > 0 && (
        <div className="flex flex-wrap gap-1.5">
          {(campaign.keywords as string[]).slice(0, 4).map((kw, i) => (
            <span key={i} className="text-xs bg-muted px-2 py-0.5 rounded-md text-muted-foreground">
              {kw}
            </span>
          ))}
          {(campaign.keywords as string[]).length > 4 && (
            <span className="text-xs text-muted-foreground">+{(campaign.keywords as string[]).length - 4} more</span>
          )}
        </div>
      )}
    </Card>
  );
}

export default function Dashboard() {
  const { user, isLoading: authLoading, logout } = useAuth();
  const [, setLocation] = useLocation();
  const { toast } = useToast();

  const { data: adminCheck } = useQuery<{ isAdmin: boolean }>({
    queryKey: ["/api/admin/check"],
    enabled: !!user,
  });

  useEffect(() => {
    if (!authLoading && !user) {
      window.location.href = "/api/login";
    }
  }, [authLoading, user]);

  const { data: businesses, isLoading: bizLoading } = useQuery<Business[]>({
    queryKey: ["/api/businesses"],
    enabled: !!user,
  });

  const { data: campaigns, isLoading: campLoading } = useQuery<Campaign[]>({
    queryKey: ["/api/campaigns"],
    enabled: !!user,
  });

  const { data: leadsData, isLoading: leadsLoading } = useQuery<{ leads: Lead[]; responses: AiResponse[] }>({
    queryKey: ["/api/leads"],
    enabled: !!user,
  });

  if (authLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <div className="space-y-4 text-center">
          <Eye className="w-8 h-8 text-primary mx-auto animate-pulse" />
          <p className="text-sm text-muted-foreground">Loading...</p>
        </div>
      </div>
    );
  }

  if (!user) return null;

  const leads = leadsData?.leads || [];
  const responses = leadsData?.responses || [];
  const hasBusiness = businesses && businesses.length > 0;

  return (
    <div className="min-h-screen bg-background">
      <header className="sticky top-0 z-50 backdrop-blur-xl bg-background/80 border-b">
        <div className="max-w-6xl mx-auto px-4 sm:px-6 h-16 flex items-center justify-between gap-4">
          <div className="flex items-center gap-2">
            <img src="/images/logo.png" alt="Gemin-Eye" className="w-6 h-6" />
            <span className="font-semibold text-lg tracking-tight">Gemin-Eye</span>
          </div>
          <div className="flex items-center gap-3">
            {adminCheck?.isAdmin && (
              <Button variant="ghost" size="icon" onClick={() => setLocation("/admin")} data-testid="button-admin">
                <Settings className="w-4 h-4" />
              </Button>
            )}
            <Avatar className="w-8 h-8">
              <AvatarImage src={user.profileImageUrl || ""} />
              <AvatarFallback className="text-xs">{user.firstName?.[0] || user.email?.[0] || "U"}</AvatarFallback>
            </Avatar>
            <span className="text-sm hidden sm:block">{user.firstName || user.email}</span>
            <Button variant="ghost" size="icon" onClick={() => logout()} data-testid="button-logout">
              <LogOut className="w-4 h-4" />
            </Button>
          </div>
        </div>
      </header>

      <main className="max-w-6xl mx-auto px-4 sm:px-6 py-8 space-y-8">
        {!hasBusiness ? (
          <div className="text-center py-20 space-y-6">
            <div className="w-16 h-16 mx-auto rounded-full bg-primary/10 flex items-center justify-center">
              <Eye className="w-8 h-8 text-primary" />
            </div>
            <div className="space-y-2">
              <h2 className="text-2xl font-serif font-bold">Welcome to Gemin-Eye</h2>
              <p className="text-muted-foreground max-w-md mx-auto">
                Set up your business profile and let AI generate your customer acquisition strategy.
              </p>
            </div>
            <Button size="lg" onClick={() => setLocation("/onboarding")} data-testid="button-setup-business">
              Set Up Your Business <ArrowRight className="w-4 h-4 ml-2" />
            </Button>
          </div>
        ) : (
          <>
            <div className="flex items-center justify-between gap-4">
              <div>
                <h1 className="text-2xl font-bold" data-testid="text-dashboard-title">Dashboard</h1>
                <p className="text-sm text-muted-foreground">{businesses?.[0]?.name}</p>
              </div>
              <Button onClick={() => setLocation("/onboarding")} data-testid="button-new-campaign">
                <Plus className="w-4 h-4 mr-1" /> New Campaign
              </Button>
            </div>

            <div className="grid grid-cols-2 lg:grid-cols-4 gap-4">
              <StatCard
                title="Active Campaigns"
                value={campaigns?.filter((c) => c.status === "active").length || 0}
                icon={Target}
                color="bg-primary/10 text-primary"
              />
              <StatCard
                title="Leads Found"
                value={leads.length}
                icon={Users}
                color="bg-chart-2/10 text-chart-2"
              />
              <StatCard
                title="Responses Sent"
                value={responses.filter((r) => r.status === "approved").length}
                icon={MessageCircle}
                color="bg-chart-3/10 text-chart-3"
              />
              <StatCard
                title="Avg. Intent Score"
                value={leads.length > 0 ? (leads.reduce((s, l) => s + l.intentScore, 0) / leads.length).toFixed(1) : "0"}
                icon={Zap}
                color="bg-chart-4/10 text-chart-4"
              />
            </div>

            {campaigns && campaigns.length > 0 && (
              <div className="space-y-4">
                <h2 className="text-lg font-semibold" data-testid="text-campaigns-title">Active Campaigns</h2>
                <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {campaigns.map((c) => (
                    <CampaignCard key={c.id} campaign={c} />
                  ))}
                </div>
              </div>
            )}

            <div className="space-y-4">
              <div className="flex items-center justify-between gap-4">
                <h2 className="text-lg font-semibold" data-testid="text-leads-title">Recent Leads</h2>
                {leads.length > 0 && (
                  <Badge variant="secondary" className="text-xs">{leads.length} total</Badge>
                )}
              </div>
              {leadsLoading ? (
                <div className="space-y-4">
                  {[1, 2, 3].map((i) => (
                    <Skeleton key={i} className="h-40 w-full rounded-md" />
                  ))}
                </div>
              ) : leads.length === 0 ? (
                <Card className="p-8 text-center space-y-3">
                  <Target className="w-8 h-8 mx-auto text-muted-foreground" />
                  <p className="text-sm text-muted-foreground">No leads yet. Your AI agent is monitoring target groups.</p>
                </Card>
              ) : (
                <div className="space-y-4">
                  {leads.map((lead) => {
                    const resp = responses.find((r) => r.leadId === lead.id);
                    return <LeadCard key={lead.id} lead={lead} response={resp} />;
                  })}
                </div>
              )}
            </div>
          </>
        )}
      </main>
    </div>
  );
}


============================================================
FILE: client/src/pages/onboarding.tsx (499 lines)
============================================================
import { useState } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { useLocation } from "wouter";
import { useAuth } from "@/hooks/use-auth";
import { apiRequest } from "@/lib/queryClient";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Form, FormControl, FormField, FormItem, FormLabel, FormMessage
} from "@/components/ui/form";
import {
  Select, SelectContent, SelectItem, SelectTrigger, SelectValue
} from "@/components/ui/select";
import {
  Eye, ArrowRight, ArrowLeft, Loader2, Sparkles, Target,
  CheckCircle, Bot, Zap, MapPin, MessageCircle, Copy, ExternalLink
} from "lucide-react";
import { SiFacebook, SiReddit } from "react-icons/si";
import { useToast } from "@/hooks/use-toast";

const businessFormSchema = z.object({
  name: z.string().min(1, "Business name is required"),
  type: z.string().min(1, "Business type is required"),
  contactEmail: z.string().email("Please enter a valid email address"),
  contactPhone: z.string().min(1, "Phone number is required"),
  website: z.string().optional().default(""),
  location: z.string().optional().default(""),
  targetAudience: z.string().min(1, "Target audience is required"),
  coreOffering: z.string().min(10, "Please describe your core offering in more detail"),
  preferredTone: z.string().min(1, "Please select a tone"),
});

type BusinessFormData = z.infer<typeof businessFormSchema>;

interface StrategyResult {
  platforms: Array<{ name: string; icon: string }>;
  groups: string[];
  keywords: string[];
  sampleResponse: string;
  rationale: string;
}

export default function OnboardingPage() {
  const { user, isLoading: authLoading } = useAuth();
  const [, setLocation] = useLocation();
  const { toast } = useToast();
  const queryClient = useQueryClient();
  const [step, setStep] = useState<"profile" | "strategy" | "complete">("profile");
  const [strategy, setStrategy] = useState<StrategyResult | null>(null);

  const form = useForm<BusinessFormData>({
    resolver: zodResolver(businessFormSchema),
    defaultValues: {
      name: "",
      type: "",
      contactEmail: "",
      contactPhone: "",
      website: "",
      location: "",
      targetAudience: "",
      coreOffering: "",
      preferredTone: "empathetic",
    },
  });

  const generateStrategy = useMutation({
    mutationFn: async (data: BusinessFormData) => {
      const res = await apiRequest("POST", "/api/strategy/generate", data);
      return res.json();
    },
    onSuccess: (data) => {
      setStrategy(data);
      setStep("strategy");
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to generate strategy. Please try again.",
        variant: "destructive",
      });
    },
  });

  const createBusiness = useMutation({
    mutationFn: async (data: BusinessFormData & { strategy: StrategyResult }) => {
      const res = await apiRequest("POST", "/api/businesses", data);
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/businesses"] });
      queryClient.invalidateQueries({ queryKey: ["/api/campaigns"] });
      queryClient.invalidateQueries({ queryKey: ["/api/leads"] });
      setStep("complete");
    },
    onError: () => {
      toast({
        title: "Error",
        description: "Failed to save your business. Please try again.",
        variant: "destructive",
      });
    },
  });

  const onSubmitProfile = (data: BusinessFormData) => {
    generateStrategy.mutate(data);
  };

  const onApproveStrategy = () => {
    if (!strategy) return;
    const formData = form.getValues();
    createBusiness.mutate({ ...formData, strategy });
  };

  if (authLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Eye className="w-8 h-8 text-primary animate-pulse" />
      </div>
    );
  }

  if (!user) {
    window.location.href = "/api/login";
    return null;
  }

  return (
    <div className="min-h-screen bg-background">
      <nav className="border-b">
        <div className="max-w-4xl mx-auto px-4 sm:px-6 h-16 flex items-center justify-between gap-4">
          <div className="flex items-center gap-2 cursor-pointer" onClick={() => setLocation("/")}>
            <Eye className="w-5 h-5 text-primary" />
            <span className="font-semibold text-lg tracking-tight">Gemin-Eye</span>
          </div>
          <div className="flex items-center gap-2">
            <div className={`w-2 h-2 rounded-full ${step === "profile" ? "bg-primary" : "bg-chart-2"}`} />
            <div className={`w-8 h-0.5 ${step !== "profile" ? "bg-chart-2" : "bg-muted"}`} />
            <div className={`w-2 h-2 rounded-full ${step === "strategy" ? "bg-primary" : step === "complete" ? "bg-chart-2" : "bg-muted"}`} />
            <div className={`w-8 h-0.5 ${step === "complete" ? "bg-chart-2" : "bg-muted"}`} />
            <div className={`w-2 h-2 rounded-full ${step === "complete" ? "bg-primary" : "bg-muted"}`} />
          </div>
        </div>
      </nav>

      <main className="max-w-2xl mx-auto px-4 sm:px-6 py-12">
        {step === "profile" && (
          <div className="space-y-8">
            <div className="space-y-2">
              <h1 className="text-3xl font-serif font-bold" data-testid="text-onboarding-title">Setup Your Agent</h1>
              <p className="text-muted-foreground">
                Provide the intelligence Gemin-Eye needs to represent you.
              </p>
            </div>

            <Form {...form}>
              <form onSubmit={form.handleSubmit(onSubmitProfile)} className="space-y-6">
                <Card className="p-6 space-y-5">
                  <h2 className="font-semibold flex items-center gap-2">
                    <Target className="w-4 h-4 text-primary" /> Business Profile
                  </h2>

                  <FormField
                    control={form.control}
                    name="name"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Business Name</FormLabel>
                        <FormControl>
                          <Input placeholder="e.g., Doro Mind" {...field} data-testid="input-business-name" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="type"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Business Type / Niche</FormLabel>
                        <FormControl>
                          <Input placeholder="e.g., Psychiatric care for serious mental illness" {...field} data-testid="input-business-type" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="contactEmail"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Email</FormLabel>
                        <FormControl>
                          <Input type="email" placeholder="e.g., you@yourbusiness.com" {...field} data-testid="input-email" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="contactPhone"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Phone Number</FormLabel>
                        <FormControl>
                          <Input type="tel" placeholder="e.g., (312) 555-1234" {...field} data-testid="input-phone" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="website"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Website <span className="text-muted-foreground font-normal">(optional)</span></FormLabel>
                        <FormControl>
                          <Input placeholder="e.g., https://yourbusiness.com" {...field} data-testid="input-website" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="location"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Location / Reach</FormLabel>
                        <FormControl>
                          <Input placeholder="e.g., Chicago IL, National, or Global / Web-based" {...field} data-testid="input-location" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="targetAudience"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Target Audience</FormLabel>
                        <FormControl>
                          <Input placeholder="e.g., Caregivers of patients with schizophrenia" {...field} data-testid="input-target-audience" />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="coreOffering"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Core Offering & Unique Value</FormLabel>
                        <FormControl>
                          <Textarea
                            placeholder="Describe what makes your business unique and what you offer..."
                            className="resize-none"
                            rows={4}
                            {...field}
                            data-testid="input-core-offering"
                          />
                        </FormControl>
                        <FormMessage />
                      </FormItem>
                    )}
                  />

                  <FormField
                    control={form.control}
                    name="preferredTone"
                    render={({ field }) => (
                      <FormItem>
                        <FormLabel>Preferred Tone</FormLabel>
                        <Select onValueChange={field.onChange} defaultValue={field.value}>
                          <FormControl>
                            <SelectTrigger data-testid="select-tone">
                              <SelectValue placeholder="Select tone" />
                            </SelectTrigger>
                          </FormControl>
                          <SelectContent>
                            <SelectItem value="empathetic">Empathetic & Supportive</SelectItem>
                            <SelectItem value="professional">Professional & Authoritative</SelectItem>
                            <SelectItem value="casual">Casual & Friendly</SelectItem>
                          </SelectContent>
                        </Select>
                        <FormMessage />
                      </FormItem>
                    )}
                  />
                </Card>

                <Button
                  type="submit"
                  size="lg"
                  className="w-full"
                  disabled={generateStrategy.isPending}
                  data-testid="button-generate-strategy"
                >
                  {generateStrategy.isPending ? (
                    <>
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                      AI is Analyzing Your Business...
                    </>
                  ) : (
                    <>
                      <Sparkles className="w-4 h-4 mr-2" />
                      Generate AI Strategy
                    </>
                  )}
                </Button>
              </form>
            </Form>
          </div>
        )}

        {step === "strategy" && strategy && (
          <div className="space-y-8">
            <div className="space-y-2">
              <div className="flex items-center gap-2">
                <Button variant="ghost" size="icon" onClick={() => setStep("profile")} data-testid="button-back">
                  <ArrowLeft className="w-4 h-4" />
                </Button>
                <h1 className="text-3xl font-serif font-bold" data-testid="text-strategy-title">Your AI Strategy</h1>
              </div>
              <p className="text-muted-foreground pl-12">
                Review the strategy Gemin-Eye created for your business.
              </p>
            </div>

            <Card className="p-6 space-y-5">
              <h2 className="font-semibold flex items-center gap-2">
                <Bot className="w-4 h-4 text-primary" /> Strategy Rationale
              </h2>
              <p className="text-sm leading-relaxed text-muted-foreground" data-testid="text-strategy-rationale">
                {strategy.rationale}
              </p>
            </Card>

            <Card className="p-6 space-y-5">
              <h2 className="font-semibold flex items-center gap-2">
                <Target className="w-4 h-4 text-primary" /> Recommended Platforms & Groups
              </h2>
              <div className="flex flex-wrap gap-2">
                {strategy.platforms.map((p) => (
                  <Badge key={p.name} variant="secondary" className="text-xs">
                    {p.name === "Facebook" && <SiFacebook className="w-3 h-3 mr-1" />}
                    {p.name === "Reddit" && <SiReddit className="w-3 h-3 mr-1" />}
                    {p.name}
                  </Badge>
                ))}
              </div>
              <div className="space-y-2">
                <span className="text-sm font-medium">Target Groups</span>
                <div className="grid gap-2">
                  {strategy.groups.map((g, i) => (
                    <div key={i} className="flex items-center gap-2 text-sm text-muted-foreground bg-muted/50 px-3 py-2 rounded-md">
                      <CheckCircle className="w-3 h-3 text-chart-2 flex-shrink-0" />
                      {g}
                    </div>
                  ))}
                </div>
              </div>
            </Card>

            <Card className="p-6 space-y-5">
              <h2 className="font-semibold flex items-center gap-2">
                <Zap className="w-4 h-4 text-primary" /> Keywords to Monitor
              </h2>
              <div className="flex flex-wrap gap-2">
                {strategy.keywords.map((kw, i) => (
                  <Badge key={i} variant="secondary" className="text-xs font-mono">{kw}</Badge>
                ))}
              </div>
            </Card>

            <Card className="p-6 space-y-5">
              <h2 className="font-semibold flex items-center gap-2">
                <Sparkles className="w-4 h-4 text-primary" /> Sample AI Response
              </h2>
              <div className="bg-muted/50 p-4 rounded-md">
                <p className="text-sm leading-relaxed italic text-muted-foreground" data-testid="text-sample-response">
                  "{strategy.sampleResponse}"
                </p>
              </div>
            </Card>

            <Button
              size="lg"
              className="w-full"
              onClick={onApproveStrategy}
              disabled={createBusiness.isPending}
              data-testid="button-approve-strategy"
            >
              {createBusiness.isPending ? (
                <>
                  <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                  Setting Up Your Agent...
                </>
              ) : (
                <>
                  <CheckCircle className="w-4 h-4 mr-2" />
                  Approve & Launch Campaign
                </>
              )}
            </Button>
          </div>
        )}

        {step === "complete" && (
          <div className="py-12 space-y-8">
            <div className="text-center space-y-2">
              <div className="w-20 h-20 mx-auto rounded-full bg-chart-2/10 flex items-center justify-center">
                <CheckCircle className="w-10 h-10 text-chart-2" />
              </div>
              <h2 className="text-3xl font-serif font-bold" data-testid="text-complete-title">Strategy Created!</h2>
              <p className="text-muted-foreground max-w-md mx-auto">
                Now connect Telegram to receive lead alerts instantly on your phone.
              </p>
            </div>

            <Card className="p-6 space-y-5">
              <h2 className="font-semibold flex items-center gap-2">
                <MessageCircle className="w-4 h-4 text-primary" /> Connect Telegram (Required)
              </h2>
              <p className="text-sm text-muted-foreground">
                Gemin-Eye sends you lead alerts and AI-written responses through Telegram. Tap the button below to connect:
              </p>
              <Button
                size="lg"
                className="w-full"
                onClick={() => window.open("https://t.me/kmages_bot?start=setup", "_blank")}
                data-testid="button-open-telegram"
              >
                <MessageCircle className="w-4 h-4 mr-2" />
                Open Telegram Bot
                <ExternalLink className="w-3 h-3 ml-2" />
              </Button>
              <div className="text-xs text-muted-foreground space-y-1">
                <p>The bot will walk you through a quick setup and send you your monitoring tools.</p>
              </div>
            </Card>

            <Card className="p-6 space-y-4">
              <h2 className="font-semibold flex items-center gap-2">
                <Zap className="w-4 h-4 text-primary" /> What Happens Next
              </h2>
              <div className="space-y-3 text-sm text-muted-foreground">
                <div className="flex gap-3">
                  <span className="font-semibold text-foreground shrink-0">1.</span>
                  <span><b className="text-foreground">Reddit monitoring is live</b> - AI scans your target subreddits every 5 minutes for leads</span>
                </div>
                <div className="flex gap-3">
                  <span className="font-semibold text-foreground shrink-0">2.</span>
                  <span><b className="text-foreground">Telegram alerts</b> - When a lead is found, you get a message with the AI-written response ready to post</span>
                </div>
                <div className="flex gap-3">
                  <span className="font-semibold text-foreground shrink-0">3.</span>
                  <span><b className="text-foreground">Spy Glass bookmarklets</b> - The bot will send you bookmark tools to manually scan Facebook and LinkedIn</span>
                </div>
                <div className="flex gap-3">
                  <span className="font-semibold text-foreground shrink-0">4.</span>
                  <span><b className="text-foreground">Rate responses</b> - Tap feedback buttons to teach the AI your style over time</span>
                </div>
              </div>
            </Card>

            <div className="flex gap-3">
              <Button variant="outline" className="flex-1" onClick={() => setLocation("/")} data-testid="button-go-dashboard">
                Go to Dashboard
              </Button>
              <Button className="flex-1" onClick={() => window.open("https://t.me/kmages_bot?start=setup", "_blank")} data-testid="button-telegram-cta">
                <MessageCircle className="w-4 h-4 mr-2" />
                Connect Telegram
              </Button>
            </div>
          </div>
        )}
      </main>
    </div>
  );
}


============================================================
FILE: client/src/pages/admin.tsx (587 lines)
============================================================
import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useAuth } from "@/hooks/use-auth";
import { useLocation } from "wouter";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Skeleton } from "@/components/ui/skeleton";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
  DialogDescription,
} from "@/components/ui/dialog";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Eye, Settings, ChevronLeft, ChevronDown, ChevronRight, Pencil, Trash2,
  Plus, Save, X, Users, Target, Hash, Globe, Mail, Phone, Link2
} from "lucide-react";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import type { Business, Campaign } from "@shared/schema";

type AdminBusiness = Business & { campaigns: Campaign[]; leadCount: number };

function TagEditor({ tags, onChange, placeholder }: { tags: string[]; onChange: (t: string[]) => void; placeholder: string }) {
  const [input, setInput] = useState("");

  const addTag = () => {
    const trimmed = input.trim();
    if (trimmed && !tags.includes(trimmed)) {
      onChange([...tags, trimmed]);
      setInput("");
    }
  };

  const removeTag = (idx: number) => {
    onChange(tags.filter((_, i) => i !== idx));
  };

  return (
    <div className="space-y-2">
      <div className="flex flex-wrap gap-1.5">
        {tags.map((tag, i) => (
          <Badge key={i} variant="secondary" className="text-xs gap-1">
            {tag}
            <button onClick={() => removeTag(i)} className="ml-0.5 opacity-60 hover:opacity-100">
              <X className="w-3 h-3" />
            </button>
          </Badge>
        ))}
      </div>
      <div className="flex gap-2">
        <Input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder={placeholder}
          onKeyDown={(e) => { if (e.key === "Enter") { e.preventDefault(); addTag(); } }}
          className="flex-1"
          data-testid="input-tag-add"
        />
        <Button variant="outline" size="sm" onClick={addTag} data-testid="button-add-tag">
          <Plus className="w-3 h-3" />
        </Button>
      </div>
    </div>
  );
}

function CampaignEditor({ campaign, onSave, onDelete }: {
  campaign: Campaign;
  onSave: (data: Partial<Campaign>) => void;
  onDelete: () => void;
}) {
  const [editing, setEditing] = useState(false);
  const [name, setName] = useState(campaign.name);
  const [status, setStatus] = useState(campaign.status);
  const [keywords, setKeywords] = useState<string[]>((campaign.keywords as string[]) || []);
  const [targetGroups, setTargetGroups] = useState<string[]>((campaign.targetGroups as string[]) || []);

  const handleSave = () => {
    onSave({ name, status, keywords, targetGroups });
    setEditing(false);
  };

  const handleCancel = () => {
    setName(campaign.name);
    setStatus(campaign.status);
    setKeywords((campaign.keywords as string[]) || []);
    setTargetGroups((campaign.targetGroups as string[]) || []);
    setEditing(false);
  };

  if (!editing) {
    return (
      <Card className="p-4 space-y-3" data-testid={`card-admin-campaign-${campaign.id}`}>
        <div className="flex items-center justify-between gap-3">
          <div className="flex items-center gap-2 min-w-0">
            <Badge variant="secondary" className="text-xs flex-shrink-0">{campaign.platform}</Badge>
            <span className="font-medium text-sm truncate">{campaign.name}</span>
          </div>
          <div className="flex items-center gap-1 flex-shrink-0">
            <Badge variant={campaign.status === "active" ? "default" : "secondary"} className="text-xs">
              {campaign.status}
            </Badge>
            <Button variant="ghost" size="icon" onClick={() => setEditing(true)} data-testid={`button-edit-campaign-${campaign.id}`}>
              <Pencil className="w-3.5 h-3.5" />
            </Button>
            <Button variant="ghost" size="icon" onClick={onDelete} data-testid={`button-delete-campaign-${campaign.id}`}>
              <Trash2 className="w-3.5 h-3.5 text-destructive" />
            </Button>
          </div>
        </div>
        <div className="space-y-1.5">
          <div className="flex items-center gap-1.5 text-xs text-muted-foreground">
            <Target className="w-3 h-3" />
            <span>{(campaign.targetGroups as string[])?.length || 0} groups</span>
          </div>
          {(campaign.targetGroups as string[])?.length > 0 && (
            <div className="flex flex-wrap gap-1">
              {(campaign.targetGroups as string[]).map((g, i) => (
                <span key={i} className="text-xs bg-muted px-1.5 py-0.5 rounded-md">{g}</span>
              ))}
            </div>
          )}
        </div>
        <div className="space-y-1.5">
          <div className="flex items-center gap-1.5 text-xs text-muted-foreground">
            <Hash className="w-3 h-3" />
            <span>{(campaign.keywords as string[])?.length || 0} keywords</span>
          </div>
          {(campaign.keywords as string[])?.length > 0 && (
            <div className="flex flex-wrap gap-1">
              {(campaign.keywords as string[]).map((kw, i) => (
                <span key={i} className="text-xs bg-muted px-1.5 py-0.5 rounded-md">{kw}</span>
              ))}
            </div>
          )}
        </div>
      </Card>
    );
  }

  return (
    <Card className="p-4 space-y-4 border-primary/30" data-testid={`card-edit-campaign-${campaign.id}`}>
      <div className="flex items-center justify-between gap-3">
        <span className="text-sm font-medium">Editing Campaign</span>
        <div className="flex gap-1">
          <Button variant="ghost" size="icon" onClick={handleCancel}>
            <X className="w-3.5 h-3.5" />
          </Button>
        </div>
      </div>
      <div className="space-y-3">
        <div>
          <label className="text-xs text-muted-foreground mb-1 block">Name</label>
          <Input value={name} onChange={(e) => setName(e.target.value)} data-testid="input-campaign-name" />
        </div>
        <div>
          <label className="text-xs text-muted-foreground mb-1 block">Status</label>
          <Select value={status} onValueChange={setStatus}>
            <SelectTrigger data-testid="select-campaign-status">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="active">Active</SelectItem>
              <SelectItem value="paused">Paused</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <div>
          <label className="text-xs text-muted-foreground mb-1 block">Target Groups / Subreddits</label>
          <TagEditor tags={targetGroups} onChange={setTargetGroups} placeholder="Add group (e.g. r/chicago)" />
        </div>
        <div>
          <label className="text-xs text-muted-foreground mb-1 block">Keywords</label>
          <TagEditor tags={keywords} onChange={setKeywords} placeholder="Add keyword" />
        </div>
      </div>
      <div className="flex justify-end gap-2">
        <Button variant="outline" size="sm" onClick={handleCancel}>Cancel</Button>
        <Button size="sm" onClick={handleSave} data-testid="button-save-campaign">
          <Save className="w-3 h-3 mr-1" /> Save
        </Button>
      </div>
    </Card>
  );
}

function BusinessPanel({ business, onRefresh }: { business: AdminBusiness; onRefresh: () => void }) {
  const [expanded, setExpanded] = useState(false);
  const [editingBiz, setEditingBiz] = useState(false);
  const [showNewCampaign, setShowNewCampaign] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const { toast } = useToast();

  const [bizName, setBizName] = useState(business.name);
  const [bizType, setBizType] = useState(business.type);
  const [bizEmail, setBizEmail] = useState(business.contactEmail || "");
  const [bizPhone, setBizPhone] = useState(business.contactPhone || "");
  const [bizWebsite, setBizWebsite] = useState(business.website || "");
  const [bizAudience, setBizAudience] = useState(business.targetAudience);
  const [bizOffering, setBizOffering] = useState(business.coreOffering);
  const [bizTone, setBizTone] = useState(business.preferredTone);

  const [newCampName, setNewCampName] = useState("");
  const [newCampPlatform, setNewCampPlatform] = useState("Reddit");

  const updateBiz = useMutation({
    mutationFn: async (data: any) => {
      const res = await apiRequest("PATCH", `/api/admin/businesses/${business.id}`, data);
      return res.json();
    },
    onSuccess: () => {
      toast({ title: "Business updated" });
      queryClient.invalidateQueries({ queryKey: ["/api/admin/businesses"] });
      setEditingBiz(false);
    },
    onError: () => toast({ title: "Failed to update", variant: "destructive" }),
  });

  const deleteBiz = useMutation({
    mutationFn: async () => {
      await apiRequest("DELETE", `/api/admin/businesses/${business.id}`);
    },
    onSuccess: () => {
      toast({ title: "Business deleted" });
      queryClient.invalidateQueries({ queryKey: ["/api/admin/businesses"] });
    },
    onError: () => toast({ title: "Failed to delete", variant: "destructive" }),
  });

  const updateCamp = useMutation({
    mutationFn: async ({ id, data }: { id: number; data: any }) => {
      const res = await apiRequest("PATCH", `/api/admin/campaigns/${id}`, data);
      return res.json();
    },
    onSuccess: () => {
      toast({ title: "Campaign updated" });
      queryClient.invalidateQueries({ queryKey: ["/api/admin/businesses"] });
    },
    onError: () => toast({ title: "Failed to update campaign", variant: "destructive" }),
  });

  const deleteCamp = useMutation({
    mutationFn: async (id: number) => {
      await apiRequest("DELETE", `/api/admin/campaigns/${id}`);
    },
    onSuccess: () => {
      toast({ title: "Campaign deleted" });
      queryClient.invalidateQueries({ queryKey: ["/api/admin/businesses"] });
    },
    onError: () => toast({ title: "Failed to delete campaign", variant: "destructive" }),
  });

  const createCamp = useMutation({
    mutationFn: async (data: any) => {
      const res = await apiRequest("POST", "/api/admin/campaigns", data);
      return res.json();
    },
    onSuccess: () => {
      toast({ title: "Campaign created" });
      queryClient.invalidateQueries({ queryKey: ["/api/admin/businesses"] });
      setShowNewCampaign(false);
      setNewCampName("");
      setNewCampPlatform("Reddit");
    },
    onError: () => toast({ title: "Failed to create campaign", variant: "destructive" }),
  });

  return (
    <Card className="overflow-visible" data-testid={`card-admin-business-${business.id}`}>
      <div
        className="p-5 cursor-pointer hover-elevate"
        onClick={() => setExpanded(!expanded)}
        data-testid={`button-expand-business-${business.id}`}
      >
        <div className="flex items-center justify-between gap-3">
          <div className="flex items-center gap-3 min-w-0">
            {expanded ? <ChevronDown className="w-4 h-4 flex-shrink-0" /> : <ChevronRight className="w-4 h-4 flex-shrink-0" />}
            <div className="min-w-0">
              <h3 className="font-semibold truncate">{business.name}</h3>
              <p className="text-xs text-muted-foreground truncate">{business.type}</p>
            </div>
          </div>
          <div className="flex items-center gap-2 flex-shrink-0">
            <Badge variant="secondary" className="text-xs">
              <Target className="w-3 h-3 mr-1" />{business.campaigns.length} campaigns
            </Badge>
            <Badge variant="secondary" className="text-xs">
              <Users className="w-3 h-3 mr-1" />{business.leadCount} leads
            </Badge>
          </div>
        </div>
        {!expanded && (
          <div className="flex flex-wrap items-center gap-2 mt-2 ml-7">
            {business.contactEmail && (
              <span className="text-xs text-muted-foreground flex items-center gap-1"><Mail className="w-3 h-3" />{business.contactEmail}</span>
            )}
            {business.contactPhone && (
              <span className="text-xs text-muted-foreground flex items-center gap-1"><Phone className="w-3 h-3" />{business.contactPhone}</span>
            )}
            {business.website && (
              <span className="text-xs text-muted-foreground flex items-center gap-1"><Link2 className="w-3 h-3" />{business.website}</span>
            )}
          </div>
        )}
      </div>

      {expanded && (
        <div className="border-t px-5 pb-5 space-y-5">
          <div className="pt-4 flex items-center justify-between gap-3">
            <h4 className="text-sm font-medium">Business Details</h4>
            <div className="flex gap-1">
              <Button variant="outline" size="sm" onClick={(e) => { e.stopPropagation(); setEditingBiz(!editingBiz); }} data-testid={`button-edit-biz-${business.id}`}>
                <Pencil className="w-3 h-3 mr-1" /> {editingBiz ? "Cancel" : "Edit"}
              </Button>
              <Button variant="outline" size="sm" onClick={(e) => { e.stopPropagation(); setShowDeleteConfirm(true); }} data-testid={`button-delete-biz-${business.id}`}>
                <Trash2 className="w-3 h-3 mr-1 text-destructive" /> Delete
              </Button>
            </div>
          </div>

          {editingBiz ? (
            <div className="space-y-3">
              <div className="grid grid-cols-2 gap-3">
                <div>
                  <label className="text-xs text-muted-foreground mb-1 block">Name</label>
                  <Input value={bizName} onChange={(e) => setBizName(e.target.value)} data-testid="input-biz-name" />
                </div>
                <div>
                  <label className="text-xs text-muted-foreground mb-1 block">Type</label>
                  <Input value={bizType} onChange={(e) => setBizType(e.target.value)} data-testid="input-biz-type" />
                </div>
              </div>
              <div className="grid grid-cols-3 gap-3">
                <div>
                  <label className="text-xs text-muted-foreground mb-1 block">Email</label>
                  <Input value={bizEmail} onChange={(e) => setBizEmail(e.target.value)} data-testid="input-biz-email" />
                </div>
                <div>
                  <label className="text-xs text-muted-foreground mb-1 block">Phone</label>
                  <Input value={bizPhone} onChange={(e) => setBizPhone(e.target.value)} data-testid="input-biz-phone" />
                </div>
                <div>
                  <label className="text-xs text-muted-foreground mb-1 block">Website</label>
                  <Input value={bizWebsite} onChange={(e) => setBizWebsite(e.target.value)} data-testid="input-biz-website" />
                </div>
              </div>
              <div>
                <label className="text-xs text-muted-foreground mb-1 block">Target Audience</label>
                <Textarea value={bizAudience} onChange={(e) => setBizAudience(e.target.value)} className="resize-none" data-testid="input-biz-audience" />
              </div>
              <div>
                <label className="text-xs text-muted-foreground mb-1 block">Core Offering</label>
                <Textarea value={bizOffering} onChange={(e) => setBizOffering(e.target.value)} className="resize-none" data-testid="input-biz-offering" />
              </div>
              <div>
                <label className="text-xs text-muted-foreground mb-1 block">Preferred Tone</label>
                <Select value={bizTone} onValueChange={setBizTone}>
                  <SelectTrigger data-testid="select-biz-tone">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="empathetic">Empathetic</SelectItem>
                    <SelectItem value="professional">Professional</SelectItem>
                    <SelectItem value="casual">Casual</SelectItem>
                    <SelectItem value="helpful">Helpful</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div className="flex justify-end">
                <Button
                  size="sm"
                  onClick={() => updateBiz.mutate({
                    name: bizName, type: bizType,
                    contactEmail: bizEmail || null, contactPhone: bizPhone || null, website: bizWebsite || null,
                    targetAudience: bizAudience, coreOffering: bizOffering, preferredTone: bizTone,
                  })}
                  disabled={updateBiz.isPending}
                  data-testid="button-save-biz"
                >
                  <Save className="w-3 h-3 mr-1" /> {updateBiz.isPending ? "Saving..." : "Save Changes"}
                </Button>
              </div>
            </div>
          ) : (
            <div className="grid grid-cols-2 gap-x-6 gap-y-2 text-sm">
              <div><span className="text-muted-foreground">Email:</span> {business.contactEmail || "—"}</div>
              <div><span className="text-muted-foreground">Phone:</span> {business.contactPhone || "—"}</div>
              <div><span className="text-muted-foreground">Website:</span> {business.website || "—"}</div>
              <div><span className="text-muted-foreground">Tone:</span> {business.preferredTone}</div>
              <div className="col-span-2"><span className="text-muted-foreground">Audience:</span> {business.targetAudience}</div>
              <div className="col-span-2"><span className="text-muted-foreground">Offering:</span> {business.coreOffering}</div>
            </div>
          )}

          <div className="space-y-3">
            <div className="flex items-center justify-between gap-3">
              <h4 className="text-sm font-medium">Campaigns ({business.campaigns.length})</h4>
              <Button variant="outline" size="sm" onClick={() => setShowNewCampaign(true)} data-testid={`button-add-campaign-${business.id}`}>
                <Plus className="w-3 h-3 mr-1" /> Add Campaign
              </Button>
            </div>

            {showNewCampaign && (
              <Card className="p-4 space-y-3 border-primary/30">
                <span className="text-sm font-medium">New Campaign</span>
                <div className="grid grid-cols-2 gap-3">
                  <div>
                    <label className="text-xs text-muted-foreground mb-1 block">Name</label>
                    <Input value={newCampName} onChange={(e) => setNewCampName(e.target.value)} placeholder="Campaign name" data-testid="input-new-camp-name" />
                  </div>
                  <div>
                    <label className="text-xs text-muted-foreground mb-1 block">Platform</label>
                    <Select value={newCampPlatform} onValueChange={setNewCampPlatform}>
                      <SelectTrigger data-testid="select-new-camp-platform">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="Reddit">Reddit</SelectItem>
                        <SelectItem value="Facebook">Facebook</SelectItem>
                        <SelectItem value="LinkedIn">LinkedIn</SelectItem>
                        <SelectItem value="google_alerts">Google Alerts</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                </div>
                <div className="flex justify-end gap-2">
                  <Button variant="outline" size="sm" onClick={() => setShowNewCampaign(false)}>Cancel</Button>
                  <Button
                    size="sm"
                    onClick={() => createCamp.mutate({ businessId: business.id, name: newCampName || `${newCampPlatform} Campaign`, platform: newCampPlatform, keywords: [], targetGroups: [] })}
                    disabled={createCamp.isPending}
                    data-testid="button-create-campaign"
                  >
                    <Plus className="w-3 h-3 mr-1" /> {createCamp.isPending ? "Creating..." : "Create"}
                  </Button>
                </div>
              </Card>
            )}

            <div className="space-y-3">
              {business.campaigns.map((camp) => (
                <CampaignEditor
                  key={camp.id}
                  campaign={camp}
                  onSave={(data) => updateCamp.mutate({ id: camp.id, data })}
                  onDelete={() => deleteCamp.mutate(camp.id)}
                />
              ))}
              {business.campaigns.length === 0 && (
                <p className="text-sm text-muted-foreground text-center py-4">No campaigns yet</p>
              )}
            </div>
          </div>
        </div>
      )}

      <Dialog open={showDeleteConfirm} onOpenChange={setShowDeleteConfirm}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Delete {business.name}?</DialogTitle>
            <DialogDescription>
              This will permanently delete this business and all its campaigns. This cannot be undone.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowDeleteConfirm(false)}>Cancel</Button>
            <Button
              variant="destructive"
              onClick={() => { deleteBiz.mutate(); setShowDeleteConfirm(false); }}
              disabled={deleteBiz.isPending}
              data-testid="button-confirm-delete-biz"
            >
              {deleteBiz.isPending ? "Deleting..." : "Delete Business"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </Card>
  );
}

export default function AdminPage() {
  const { user, isLoading: authLoading, logout } = useAuth();
  const [, setLocation] = useLocation();

  const { data: adminCheck } = useQuery<{ isAdmin: boolean }>({
    queryKey: ["/api/admin/check"],
    enabled: !!user,
  });

  const { data: businesses, isLoading } = useQuery<AdminBusiness[]>({
    queryKey: ["/api/admin/businesses"],
    enabled: !!user && adminCheck?.isAdmin === true,
  });

  if (authLoading) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Eye className="w-8 h-8 text-primary animate-pulse" />
      </div>
    );
  }

  if (!user) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Eye className="w-8 h-8 text-primary animate-pulse" />
      </div>
    );
  }

  if (!adminCheck) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Eye className="w-8 h-8 text-primary animate-pulse" />
      </div>
    );
  }

  if (!adminCheck.isAdmin) {
    return (
      <div className="min-h-screen bg-background flex items-center justify-center">
        <Card className="p-8 text-center space-y-3 max-w-md">
          <Settings className="w-8 h-8 mx-auto text-muted-foreground" />
          <h2 className="text-lg font-semibold">Admin Access Required</h2>
          <p className="text-sm text-muted-foreground">You don't have permission to view this page.</p>
          <Button variant="outline" onClick={() => setLocation("/")} data-testid="button-back-home">
            <ChevronLeft className="w-3 h-3 mr-1" /> Back to Dashboard
          </Button>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background">
      <header className="sticky top-0 z-50 backdrop-blur-xl bg-background/80 border-b">
        <div className="max-w-5xl mx-auto px-4 sm:px-6 h-16 flex items-center justify-between gap-4">
          <div className="flex items-center gap-3">
            <Button variant="ghost" size="icon" onClick={() => setLocation("/")} data-testid="button-admin-back">
              <ChevronLeft className="w-4 h-4" />
            </Button>
            <div className="flex items-center gap-2">
              <Settings className="w-5 h-5 text-primary" />
              <span className="font-semibold text-lg">Admin Panel</span>
            </div>
          </div>
          <Badge variant="secondary" className="text-xs">
            {businesses?.length || 0} clients
          </Badge>
        </div>
      </header>

      <main className="max-w-5xl mx-auto px-4 sm:px-6 py-6 space-y-4">
        {isLoading ? (
          <div className="space-y-4">
            {[1, 2, 3].map((i) => (
              <Skeleton key={i} className="h-24 w-full rounded-md" />
            ))}
          </div>
        ) : businesses && businesses.length > 0 ? (
          businesses.map((biz) => (
            <BusinessPanel key={biz.id} business={biz} onRefresh={() => queryClient.invalidateQueries({ queryKey: ["/api/admin/businesses"] })} />
          ))
        ) : (
          <Card className="p-8 text-center space-y-3">
            <Users className="w-8 h-8 mx-auto text-muted-foreground" />
            <p className="text-sm text-muted-foreground">No businesses yet.</p>
          </Card>
        )}
      </main>
    </div>
  );
}


============================================================
FILE: client/src/pages/client-guide.tsx (415 lines)
============================================================
import { useRef } from "react";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Download, ArrowLeft, MessageCircle, Globe, Facebook, BookOpen, Zap } from "lucide-react";
import { SiReddit, SiFacebook, SiTelegram, SiLinkedin } from "react-icons/si";
import { useLocation } from "wouter";

function Section({ number, title, icon, children }: { number: number; title: string; icon: React.ReactNode; children: React.ReactNode }) {
  return (
    <Card className="p-6">
      <div className="flex items-start gap-4">
        <div className="flex-shrink-0 w-10 h-10 rounded-full bg-primary text-primary-foreground flex items-center justify-center font-bold text-lg">
          {number}
        </div>
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2 mb-3 flex-wrap">
            {icon}
            <h2 className="text-xl font-semibold">{title}</h2>
          </div>
          <div className="space-y-2 text-muted-foreground">{children}</div>
        </div>
      </div>
    </Card>
  );
}

export default function ClientGuidePage() {
  const [, navigate] = useLocation();
  const printRef = useRef<HTMLDivElement>(null);

  function handleDownloadPDF() {
    const content = printRef.current;
    if (!content) return;
    const printWindow = window.open("", "_blank");
    if (!printWindow) return;
    printWindow.document.write(`<!DOCTYPE html><html><head><title>Gemin-Eye Client Setup Guide</title><style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body { font-family: system-ui, -apple-system, sans-serif; color: #1a1a2e; padding: 40px; line-height: 1.6; }
      h1 { font-size: 28px; margin-bottom: 8px; color: #4338ca; }
      .subtitle { font-size: 14px; color: #666; margin-bottom: 32px; }
      .section { margin-bottom: 28px; page-break-inside: avoid; }
      .section-header { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; }
      .section-number { width: 32px; height: 32px; border-radius: 50%; background: #4338ca; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 16px; flex-shrink: 0; }
      .section-title { font-size: 20px; font-weight: 600; }
      .section-badge { font-size: 11px; background: #e0e7ff; color: #4338ca; padding: 2px 8px; border-radius: 10px; font-weight: 600; }
      ul { padding-left: 24px; margin-top: 8px; }
      li { margin-bottom: 6px; }
      .note { background: #f5f3ff; border-left: 3px solid #6d28d9; padding: 12px 16px; margin-top: 12px; border-radius: 0 6px 6px 0; font-size: 13px; }
      .code-block { background: #f1f5f9; border: 1px solid #e2e8f0; border-radius: 6px; padding: 12px 16px; font-family: monospace; font-size: 12px; word-break: break-all; margin-top: 8px; }
      .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #e2e8f0; font-size: 12px; color: #999; text-align: center; }
      .platform-label { font-weight: 600; color: #1a1a2e; }
      @media print { body { padding: 20px; } .section { page-break-inside: avoid; } }
    </style></head><body>
      <h1>Gemin-Eye Setup Guide</h1>
      <p class="subtitle">Your AI-powered customer acquisition system &mdash; step-by-step onboarding</p>

      <div class="section">
        <div class="section-header">
          <div class="section-number">1</div>
          <div class="section-title">Install Telegram</div>
          <span class="section-badge">REQUIRED</span>
        </div>
        <p>All alerts and AI-generated responses are delivered through Telegram.</p>
        <ul>
          <li>Download Telegram from <strong>telegram.org</strong> (available on phone, tablet, and desktop)</li>
          <li>Create an account if you don't have one</li>
          <li>This is where you'll receive lead notifications with suggested responses you can copy-paste</li>
        </ul>
      </div>

      <div class="section">
        <div class="section-header">
          <div class="section-number">2</div>
          <div class="section-title">Set Up Your Business Profile</div>
          <span class="section-badge">REQUIRED</span>
        </div>
        <p>Tell the bot about your business so it knows what to look for.</p>
        <ul>
          <li>Open the Gemin-Eye bot in Telegram (your admin will send you the link)</li>
          <li>Send the command: <strong>/setup</strong></li>
          <li>Answer 3 quick questions:
            <ul>
              <li><strong>Business name</strong> &mdash; e.g., "Heart of America Whoodles"</li>
              <li><strong>What you do/sell</strong> &mdash; e.g., "We breed Whoodle puppies, a Wheaten Terrier and Poodle mix"</li>
              <li><strong>Keywords</strong> &mdash; comma-separated words people might use when looking for you, e.g., "whoodle, whoodle puppy, hypoallergenic dog, wheaten poodle mix"</li>
            </ul>
          </li>
          <li>The bot will confirm your setup and give you a bookmark code (see Step 3)</li>
        </ul>
      </div>

      <div class="section">
        <div class="section-header">
          <div class="section-number">3</div>
          <div class="section-title">Set Up the Facebook Spy Glass</div>
          <span class="section-badge">RECOMMENDED</span>
        </div>
        <p>The Spy Glass is a browser bookmark that scans Facebook Groups for potential customers.</p>
        <ul>
          <li>After completing Step 2, the bot sends you a long code starting with <strong>javascript:void(...</strong></li>
          <li>In Chrome (or your browser), right-click the bookmarks bar</li>
          <li>Click <strong>"Add bookmark"</strong> (or "Add page")</li>
          <li>Name it: <strong>Gemin-Eye</strong></li>
          <li>Paste the code the bot gave you as the <strong>URL</strong></li>
          <li>Save the bookmark</li>
        </ul>
        <div class="note">
          <strong>How to use it:</strong> Go to any Facebook Group, click your "Gemin-Eye" bookmark, and the page will automatically scroll and scan posts. Matching leads are sent to your Telegram instantly. You'll see a purple banner showing progress. Click X to stop, or it will stop automatically after about 5 minutes.
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <div class="section-number">4</div>
          <div class="section-title">Join Relevant Facebook Groups</div>
          <span class="section-badge">RECOMMENDED</span>
        </div>
        <p>The Spy Glass works inside Facebook Groups. Join groups where your potential customers hang out.</p>
        <ul>
          <li>Search Facebook for groups related to your industry, location, or niche</li>
          <li>Request to join 5-10 active groups</li>
          <li>Once approved, open each group and click your Gemin-Eye bookmark to scan</li>
          <li>Scan your groups daily or a few times per week for best results</li>
        </ul>
      </div>

      <div class="section">
        <div class="section-header">
          <div class="section-number">5</div>
          <div class="section-title">Set Up the LinkedIn Spy Glass</div>
          <span class="section-badge">RECOMMENDED</span>
        </div>
        <p>The LinkedIn Spy Glass works just like the Facebook one, but for your LinkedIn feed and search results.</p>
        <ul>
          <li>After setup, the bot also sends a second bookmarklet code for LinkedIn</li>
          <li>Create another bookmark the same way (name it <strong>Scan LinkedIn</strong>)</li>
          <li>Paste the LinkedIn code as the URL</li>
        </ul>
        <div class="note">
          <strong>Where to use it:</strong> Open your LinkedIn feed, search results, or any LinkedIn page with posts. Click the "Scan LinkedIn" bookmark and it will auto-scroll and scan for leads matching your keywords. Matched posts get highlighted in blue.
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <div class="section-number">6</div>
          <div class="section-title">Reddit Monitoring</div>
          <span class="section-badge">AUTOMATIC</span>
        </div>
        <p>Reddit is monitored automatically &mdash; no action needed from you.</p>
        <ul>
          <li>The system scans relevant subreddits every 90 seconds</li>
          <li>When someone posts a question matching your keywords, you get a Telegram alert</li>
          <li>Each alert includes a suggested response and a direct link to the post</li>
          <li>Your admin sets up which subreddits to monitor based on your business</li>
        </ul>
      </div>

      <div class="section">
        <div class="section-header">
          <div class="section-number">7</div>
          <div class="section-title">Google Alerts &mdash; Web-Wide Monitoring</div>
          <span class="section-badge">OPTIONAL</span>
        </div>
        <p>Monitor the entire web (Quora, forums, blogs, news) for people talking about your topic.</p>
        <ul>
          <li>Go to <strong>google.com/alerts</strong></li>
          <li>Type a keyword (e.g., "whoodle breeder" or "best hypoallergenic dogs")</li>
          <li>Click <strong>"Show options"</strong></li>
          <li>Change <strong>"Deliver to"</strong> from "Email" to <strong>"RSS feed"</strong></li>
          <li>Click <strong>"Create Alert"</strong></li>
          <li>Copy the RSS feed URL (right-click the RSS icon, click "Copy link address")</li>
          <li>In Telegram, send: <strong>/addalert</strong> and paste the RSS URL when prompted</li>
        </ul>
        <div class="note">
          <strong>Tip:</strong> Create 3-5 alerts for different keyword variations. The system checks each feed every 2 minutes automatically.
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <div class="section-number">8</div>
          <div class="section-title">Manual Post Scanning via Telegram</div>
          <span class="section-badge">ANYTIME</span>
        </div>
        <p>You can also manually send posts to the bot for analysis at any time.</p>
        <ul>
          <li><strong>Text posts:</strong> Paste the URL and the post text into Telegram</li>
          <li><strong>Screenshots:</strong> Take a screenshot of any post and send the image to the bot &mdash; it reads images automatically</li>
          <li>The bot will score the lead and generate a suggested response</li>
        </ul>
      </div>

      <div class="section">
        <div class="section-header">
          <div class="section-number">9</div>
          <div class="section-title">Responding to Leads</div>
          <span class="section-badge">IMPORTANT</span>
        </div>
        <p>When you get a lead alert on Telegram, here's what to do:</p>
        <ul>
          <li>Read the suggested response &mdash; it's written to sound natural, not salesy</li>
          <li>Click <strong>"Open Post"</strong> to go directly to the original post</li>
          <li>Copy the suggested response, personalize it if you want, and post it as a comment/reply</li>
          <li>Use the feedback buttons on the Telegram alert:
            <ul>
              <li><strong>Used It</strong> &mdash; you posted the response (helps the AI learn what works)</li>
              <li><strong>Bad Match</strong> &mdash; the post wasn't relevant to your business</li>
              <li><strong>Too Salesy</strong> &mdash; the response sounded too much like an ad</li>
              <li><strong>Wrong Client</strong> &mdash; matched to the wrong business</li>
            </ul>
          </li>
        </ul>
        <div class="note">
          <strong>Pro tip:</strong> The more feedback you give, the better the AI gets at finding the right leads and writing the right responses for your business.
        </div>
      </div>

      <div class="section">
        <div class="section-header">
          <div class="section-number">10</div>
          <div class="section-title">Telegram Bot Commands Reference</div>
        </div>
        <ul>
          <li><strong>/setup</strong> &mdash; Start the onboarding wizard (first time only)</li>
          <li><strong>/keywords</strong> &mdash; Update your monitoring keywords</li>
          <li><strong>/groups</strong> &mdash; Update target groups/subreddits</li>
          <li><strong>/addalert</strong> &mdash; Add a Google Alerts RSS feed</li>
          <li><strong>/alerts</strong> &mdash; View all your alert feeds</li>
          <li><strong>/removealert</strong> &mdash; Remove an alert feed</li>
          <li><strong>/businesses</strong> &mdash; See all your business profiles</li>
          <li><strong>/help</strong> &mdash; Full guide with all commands</li>
        </ul>
      </div>

      <div class="note" style="background:#ede9fe;border-left-color:#4338ca;margin-top:32px;padding:16px 20px;">
        <strong>Remember: The harder you work, the harder we work for you.</strong> Every Facebook Group you join, every LinkedIn search you scan, every Google Alert you create &mdash; that's another stream of leads flowing into your pipeline. The AI does the heavy lifting (scoring, writing responses, sending alerts), but <em>you</em> control how wide the net is. Clients who actively add groups and scan regularly see 3&ndash;5x more leads than those who set it and forget it. Put in the time, and Gemin-Eye will multiply your effort.
      </div>

      <div class="footer">
        Gemin-Eye &mdash; AI-Powered Customer Acquisition &mdash; Gemin-Eye.com
      </div>
    </body></html>`);
    printWindow.document.close();
    setTimeout(() => { printWindow.print(); }, 500);
  }

  return (
    <div className="min-h-screen bg-background">
      <div className="max-w-3xl mx-auto px-4 py-8">
        <div className="flex items-center justify-between mb-8 flex-wrap gap-4">
          <div className="flex items-center gap-3">
            <Button variant="ghost" size="icon" onClick={() => navigate("/")} data-testid="button-back">
              <ArrowLeft />
            </Button>
            <div>
              <h1 className="text-2xl font-bold">Client Setup Guide</h1>
              <p className="text-muted-foreground text-sm">Everything you need to get your campaign running</p>
            </div>
          </div>
          <Button onClick={handleDownloadPDF} data-testid="button-download-pdf">
            <Download className="w-4 h-4 mr-2" />
            Download PDF
          </Button>
        </div>

        <div ref={printRef} className="space-y-4">
          <Section number={1} title="Install Telegram" icon={<SiTelegram className="w-5 h-5 text-[#229ED9]" />}>
            <p>All alerts and AI-generated responses are delivered through Telegram.</p>
            <ul className="list-disc pl-5 space-y-1 mt-2">
              <li>Download Telegram from <a href="https://telegram.org" target="_blank" rel="noopener noreferrer" className="text-primary underline">telegram.org</a> (available on phone, tablet, and desktop)</li>
              <li>Create an account if you don't have one</li>
              <li>This is where you'll receive lead notifications with suggested responses you can copy-paste</li>
            </ul>
          </Section>

          <Section number={2} title="Set Up Your Business Profile" icon={<MessageCircle className="w-5 h-5 text-primary" />}>
            <p>Tell the bot about your business so it knows what to look for.</p>
            <ul className="list-disc pl-5 space-y-1 mt-2">
              <li>Open the Gemin-Eye bot in Telegram (your admin will send you the link)</li>
              <li>Send the command: <code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">/setup</code></li>
              <li>Answer 3 quick questions:
                <ul className="list-disc pl-5 mt-1 space-y-1">
                  <li><strong>Business name</strong> — e.g., "Heart of America Whoodles"</li>
                  <li><strong>What you do/sell</strong> — e.g., "We breed Whoodle puppies"</li>
                  <li><strong>Keywords</strong> — comma-separated words people might use, e.g., "whoodle, whoodle puppy, hypoallergenic dog"</li>
                </ul>
              </li>
              <li>The bot confirms your setup and gives you a bookmark code (Step 3)</li>
            </ul>
          </Section>

          <Section number={3} title="Set Up the Facebook Spy Glass" icon={<SiFacebook className="w-5 h-5 text-[#1877F2]" />}>
            <p>The Spy Glass is a browser bookmark that scans Facebook Groups for potential customers.</p>
            <ul className="list-disc pl-5 space-y-1 mt-2">
              <li>After Step 2, the bot sends you a long code starting with <code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">javascript:void(...</code></li>
              <li>In Chrome, right-click the bookmarks bar</li>
              <li>Click <strong>"Add bookmark"</strong></li>
              <li>Name it: <strong>Gemin-Eye</strong></li>
              <li>Paste the code as the <strong>URL</strong></li>
              <li>Save the bookmark</li>
            </ul>
            <div className="bg-muted/50 border-l-2 border-primary p-3 rounded-r-md mt-3 text-sm">
              <strong>How to use it:</strong> Go to any Facebook Group, click your "Gemin-Eye" bookmark, and the page will automatically scroll and scan posts. Matching leads are sent to your Telegram instantly. Click X to stop, or it stops automatically after ~5 minutes.
            </div>
          </Section>

          <Section number={4} title="Join Relevant Facebook Groups" icon={<Facebook className="w-5 h-5 text-[#1877F2]" />}>
            <p>The Spy Glass works inside Facebook Groups. Join groups where your potential customers hang out.</p>
            <ul className="list-disc pl-5 space-y-1 mt-2">
              <li>Search Facebook for groups related to your industry, location, or niche</li>
              <li>Request to join 5-10 active groups</li>
              <li>Once approved, open each group and click your Gemin-Eye bookmark</li>
              <li>Scan your groups daily or a few times per week for best results</li>
            </ul>
          </Section>

          <Section number={5} title="Set Up the LinkedIn Spy Glass" icon={<SiLinkedin className="w-5 h-5 text-[#0077B5]" />}>
            <p>The LinkedIn Spy Glass works just like the Facebook one, but for your LinkedIn feed and search results.</p>
            <ul className="list-disc pl-5 space-y-1 mt-2">
              <li>After setup, the bot also sends a second bookmarklet code for LinkedIn</li>
              <li>Create another bookmark the same way (name it <strong>"Scan LinkedIn"</strong>)</li>
              <li>Paste the LinkedIn code as the URL</li>
            </ul>
            <div className="bg-muted/50 border-l-2 border-primary p-3 rounded-r-md mt-3 text-sm">
              <strong>Where to use it:</strong> Open your LinkedIn feed, search results, or any LinkedIn page with posts. Click the "Scan LinkedIn" bookmark and it will auto-scroll and scan for leads matching your keywords. Matched posts get highlighted in blue.
            </div>
          </Section>

          <Section number={6} title="Reddit Monitoring" icon={<SiReddit className="w-5 h-5 text-[#FF4500]" />}>
            <p className="font-medium text-green-600 dark:text-green-400">Fully automatic — no action needed from you.</p>
            <ul className="list-disc pl-5 space-y-1 mt-2">
              <li>The system scans relevant subreddits every 90 seconds</li>
              <li>When someone posts a question matching your keywords, you get a Telegram alert</li>
              <li>Each alert includes a suggested response and a direct link to the post</li>
              <li>Your admin sets up which subreddits to monitor</li>
            </ul>
          </Section>

          <Section number={7} title="Google Alerts — Web-Wide Monitoring" icon={<Globe className="w-5 h-5 text-primary" />}>
            <p>Monitor the entire web (Quora, forums, blogs, news) for people talking about your topic.</p>
            <ul className="list-disc pl-5 space-y-1 mt-2">
              <li>Go to <a href="https://google.com/alerts" target="_blank" rel="noopener noreferrer" className="text-primary underline">google.com/alerts</a></li>
              <li>Type a keyword (e.g., "whoodle breeder")</li>
              <li>Click <strong>"Show options"</strong></li>
              <li>Change <strong>"Deliver to"</strong> to <strong>"RSS feed"</strong></li>
              <li>Click <strong>"Create Alert"</strong></li>
              <li>Copy the RSS feed URL (right-click the RSS icon, "Copy link address")</li>
              <li>In Telegram, send <code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">/addalert</code> and paste the RSS URL</li>
            </ul>
            <div className="bg-muted/50 border-l-2 border-primary p-3 rounded-r-md mt-3 text-sm">
              <strong>Tip:</strong> Create 3-5 alerts for different keyword variations. The system checks each feed every 2 minutes automatically.
            </div>
          </Section>

          <Section number={8} title="Manual Post Scanning via Telegram" icon={<MessageCircle className="w-5 h-5 text-primary" />}>
            <p>You can manually send any post to the bot for instant analysis.</p>
            <ul className="list-disc pl-5 space-y-1 mt-2">
              <li><strong>Text posts:</strong> Paste the URL + post text into Telegram</li>
              <li><strong>Screenshots:</strong> Send a screenshot of any post — the bot reads images automatically</li>
              <li>The bot scores the lead and generates a suggested response</li>
            </ul>
          </Section>

          <Section number={9} title="Responding to Leads" icon={<BookOpen className="w-5 h-5 text-primary" />}>
            <p>When you get a lead alert on Telegram:</p>
            <ul className="list-disc pl-5 space-y-1 mt-2">
              <li>Read the suggested response — it's written to sound natural, not salesy</li>
              <li>Click <strong>"Open Post"</strong> to go directly to the original post</li>
              <li>Copy the response, personalize it if you want, and post it as a reply</li>
              <li>Use the feedback buttons on the alert:
                <ul className="list-disc pl-5 mt-1 space-y-1">
                  <li><strong>Used It</strong> — you posted the response (helps the AI learn)</li>
                  <li><strong>Bad Match</strong> — the post wasn't relevant</li>
                  <li><strong>Too Salesy</strong> — response sounded too much like an ad</li>
                  <li><strong>Wrong Client</strong> — matched to the wrong business</li>
                </ul>
              </li>
            </ul>
            <div className="bg-muted/50 border-l-2 border-primary p-3 rounded-r-md mt-3 text-sm">
              <strong>Pro tip:</strong> The more feedback you give, the better the AI gets at finding the right leads and writing the right responses.
            </div>
          </Section>

          <Section number={10} title="Telegram Bot Commands" icon={<SiTelegram className="w-5 h-5 text-[#229ED9]" />}>
            <ul className="list-disc pl-5 space-y-1">
              <li><code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">/setup</code> — Start the onboarding wizard</li>
              <li><code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">/keywords</code> — Update your monitoring keywords</li>
              <li><code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">/groups</code> — Update target groups/subreddits</li>
              <li><code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">/addalert</code> — Add a Google Alerts RSS feed</li>
              <li><code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">/alerts</code> — View all your alert feeds</li>
              <li><code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">/removealert</code> — Remove an alert feed</li>
              <li><code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">/businesses</code> — See all your business profiles</li>
              <li><code className="bg-muted px-1.5 py-0.5 rounded text-sm font-mono">/help</code> — Full guide with all commands</li>
            </ul>
          </Section>

          <Card className="p-6 bg-primary/5 border-primary/20" data-testid="card-motivation">
            <div className="flex items-start gap-4">
              <div className="flex-shrink-0 w-10 h-10 rounded-full bg-primary/20 flex items-center justify-center">
                <Zap className="w-5 h-5 text-primary" />
              </div>
              <div>
                <p className="font-semibold text-base mb-2">The harder you work, the harder we work for you.</p>
                <p className="text-sm text-muted-foreground leading-relaxed">
                  Every Facebook Group you join, every LinkedIn search you scan, every Google Alert you create — that's another stream of leads flowing into your pipeline. The AI does the heavy lifting (scoring posts, writing responses, sending alerts), but <strong>you</strong> control how wide the net is. Clients who actively add groups and scan regularly see 3-5x more leads than those who set it and forget it. Put in the time, and Gemin-Eye will multiply your effort.
                </p>
              </div>
            </div>
          </Card>
        </div>
      </div>
    </div>
  );
}


============================================================
FILE: client/src/hooks/use-auth.ts (47 lines)
============================================================
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import type { User } from "@shared/models/auth";

async function fetchUser(): Promise<User | null> {
  const response = await fetch("/api/auth/user", {
    credentials: "include",
  });

  if (response.status === 401) {
    return null;
  }

  if (!response.ok) {
    throw new Error(`${response.status}: ${response.statusText}`);
  }

  return response.json();
}

async function logout(): Promise<void> {
  window.location.href = "/api/logout";
}

export function useAuth() {
  const queryClient = useQueryClient();
  const { data: user, isLoading } = useQuery<User | null>({
    queryKey: ["/api/auth/user"],
    queryFn: fetchUser,
    retry: false,
    staleTime: 1000 * 60 * 5, // 5 minutes
  });

  const logoutMutation = useMutation({
    mutationFn: logout,
    onSuccess: () => {
      queryClient.setQueryData(["/api/auth/user"], null);
    },
  });

  return {
    user,
    isLoading,
    isAuthenticated: !!user,
    logout: logoutMutation.mutate,
    isLoggingOut: logoutMutation.isPending,
  };
}


============================================================
FILE: client/src/lib/queryClient.ts (57 lines)
============================================================
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    throw new Error(`${res.status}: ${text}`);
  }
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const res = await fetch(queryKey.join("/") as string, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});


============================================================
FILE: client/src/components/theme-provider.tsx (43 lines)
============================================================
import { createContext, useContext, useEffect, useState } from "react";

type Theme = "light" | "dark";

interface ThemeContextType {
  theme: Theme;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType>({
  theme: "dark",
  toggleTheme: () => {},
});

export function ThemeProvider({ children }: { children: React.ReactNode }) {
  const [theme, setTheme] = useState<Theme>(() => {
    if (typeof window !== "undefined") {
      return (localStorage.getItem("gemin-eye-theme") as Theme) || "dark";
    }
    return "dark";
  });

  useEffect(() => {
    const root = document.documentElement;
    root.classList.remove("light", "dark");
    root.classList.add(theme);
    localStorage.setItem("gemin-eye-theme", theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme((prev) => (prev === "light" ? "dark" : "light"));
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  return useContext(ThemeContext);
}


============================================================
FILE: client/public/spy-glass.js (197 lines)
============================================================
(function() {
  if (window.__geminEyeActive) return;
  window.__geminEyeActive = true;

  var MAX_POSTS = 500;
  var SCROLL_DELAY_MS = 1500;
  var SCAN_INTERVAL_MS = 2000;

  var params = {};
  var scripts = document.getElementsByTagName('script');
  for (var i = 0; i < scripts.length; i++) {
    var src = scripts[i].src || '';
    if (src.indexOf('spy-glass.js') !== -1) {
      var url = new URL(src);
      params.cid = url.searchParams.get('cid') || '';
      params.bid = url.searchParams.get('bid') || '';
      params.tok = url.searchParams.get('tok') || '';
      break;
    }
  }

  if (!params.cid || !params.bid || !params.tok) {
    alert('Gemin-Eye: Missing configuration. Please re-run setup with /setup in the bot.');
    return;
  }

  var API_URL = (function() {
    for (var i = 0; i < scripts.length; i++) {
      var src = scripts[i].src || '';
      if (src.indexOf('spy-glass.js') !== -1) {
        var u = new URL(src);
        return u.origin + '/api/fb-scan';
      }
    }
    return '/api/fb-scan';
  })();

  var banner = document.createElement('div');
  banner.id = 'gemin-eye-banner';
  banner.style.cssText = 'position:fixed;top:0;left:0;width:100%;background:linear-gradient(135deg,#4338ca,#6d28d9);color:white;text-align:center;padding:10px 20px;z-index:99999;font-family:system-ui,sans-serif;font-size:14px;font-weight:600;box-shadow:0 2px 8px rgba(0,0,0,0.2);display:flex;align-items:center;justify-content:center;gap:12px;';

  var counter = document.createElement('span');
  counter.id = 'gemin-eye-count';
  counter.textContent = '0 scanned';
  counter.style.cssText = 'font-weight:normal;opacity:0.85;font-size:13px;';

  var stopBtn = document.createElement('span');
  stopBtn.textContent = 'Stop';
  stopBtn.style.cssText = 'cursor:pointer;background:rgba(255,255,255,0.2);padding:3px 12px;border-radius:4px;font-size:12px;font-weight:600;';

  var closeBtn = document.createElement('span');
  closeBtn.textContent = 'X';
  closeBtn.style.cssText = 'position:absolute;right:16px;cursor:pointer;font-size:16px;opacity:0.7;';

  var seenPosts = {};
  var scannedCount = 0;
  var sentCount = 0;
  var pendingCount = 0;
  var running = true;
  var scrollTimer = null;
  var scanInterval = null;
  var noNewPostsCount = 0;

  function cleanup() {
    running = false;
    window.__geminEyeActive = false;
    if (scanInterval) clearInterval(scanInterval);
    if (scrollTimer) clearTimeout(scrollTimer);
    banner.remove();
  }

  function stopScanning() {
    running = false;
    if (scanInterval) clearInterval(scanInterval);
    if (scrollTimer) clearTimeout(scrollTimer);
    stopBtn.textContent = 'Stopped';
    stopBtn.style.opacity = '0.5';
    stopBtn.style.cursor = 'default';
    updateCounter();
  }

  function updateCounter() {
    var text = scannedCount + ' scanned, ' + sentCount + ' leads';
    if (pendingCount > 0) text += ' (' + pendingCount + ' checking...)';
    if (!running) text += ' - Done';
    counter.textContent = text;
  }

  closeBtn.onclick = cleanup;
  stopBtn.onclick = function() {
    if (running) stopScanning();
  };

  banner.innerHTML = '';
  var label = document.createElement('span');
  label.textContent = 'Gemin-Eye: Auto-scanning...';
  banner.appendChild(label);
  banner.appendChild(counter);
  banner.appendChild(stopBtn);
  banner.appendChild(closeBtn);
  document.body.appendChild(banner);

  function extractPosts() {
    var found = [];
    var candidates = document.querySelectorAll('div[dir="auto"]');
    candidates.forEach(function(el) {
      var text = (el.innerText || '').trim();
      if (text.length < 25) return;
      if (text.length > 5000) return;
      if (seenPosts[text]) return;

      var parentLink = el.closest('a');
      if (parentLink && parentLink.href && parentLink.href.indexOf('/comment') === -1) return;

      found.push({ text: text, element: el });
    });
    return found;
  }

  function sendPost(postText, element) {
    seenPosts[postText] = true;
    scannedCount++;
    pendingCount++;
    updateCounter();

    var groupName = '';
    var h1 = document.querySelector('h1');
    if (h1) groupName = h1.innerText || '';
    if (!groupName) {
      var titleEl = document.querySelector('[role="banner"] a[href*="/groups/"]');
      if (titleEl) groupName = titleEl.innerText || '';
    }

    fetch(API_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chatId: params.cid,
        businessId: parseInt(params.bid, 10),
        token: params.tok,
        postText: postText,
        groupName: groupName || document.title || 'Facebook Group',
        pageUrl: window.location.href
      })
    }).then(function(res) {
      return res.json();
    }).then(function(data) {
      pendingCount--;
      if (data.matched) {
        sentCount++;
        element.style.outline = '3px solid #6d28d9';
        element.style.outlineOffset = '4px';
        element.style.borderRadius = '4px';
      }
      updateCounter();
    }).catch(function() {
      pendingCount--;
      updateCounter();
    });
  }

  function scan() {
    if (!running) return;
    var posts = extractPosts();

    if (posts.length === 0) {
      noNewPostsCount++;
    } else {
      noNewPostsCount = 0;
    }

    posts.forEach(function(p) {
      if (scannedCount >= MAX_POSTS) return;
      sendPost(p.text, p.element);
    });

    if (scannedCount >= MAX_POSTS) {
      stopScanning();
      return;
    }

    if (noNewPostsCount >= 10) {
      stopScanning();
      return;
    }
  }

  function autoScroll() {
    if (!running) return;
    window.scrollBy({ top: 600, behavior: 'smooth' });
    scrollTimer = setTimeout(autoScroll, SCROLL_DELAY_MS);
  }

  scan();
  scanInterval = setInterval(scan, SCAN_INTERVAL_MS);
  scrollTimer = setTimeout(autoScroll, SCROLL_DELAY_MS);
})();


============================================================
FILE: replit.md (185 lines)
============================================================
# Gemin-Eye - AI-Powered Customer Acquisition Platform

## Overview

Gemin-Eye is an AI-powered customer acquisition platform that monitors niche online communities (Facebook groups, Reddit, etc.) for high-intent questions, then generates helpful, human-sounding responses that subtly promote a client's business. Instead of traditional advertising, it finds people actively seeking recommendations and engages them organically.

The app has four main flows:
1. **Landing page** - Marketing page with animated demo showing how the product works
2. **Onboarding** - Multi-step wizard where users describe their business, and AI generates a monitoring strategy (platforms, target groups, keywords, sample responses)
3. **Dashboard** - Shows businesses, campaigns, leads discovered, and AI-generated responses with status tracking
4. **Admin Panel** (`/admin`) - Admin-only page to manage all clients, their businesses, campaigns, keywords, and groups

## Recent Changes (Feb 15, 2026)
- **Smart Keyword Matching** (`server/utils/keywords.ts`)
  - Replaced strict exact-phrase substring matching with smarter word-level matching
  - Multi-word keywords like "treatment options" now match when both words appear anywhere in the text, not just adjacently
  - Stop-word filtering ensures only significant words are checked (e.g., "looking for help" matches on "looking" + "help")
  - Shared utility used by all monitors: Facebook/LinkedIn scan, Reddit RSS, Google Alerts RSS
  - Exact phrase match still tried first for best precision
- **AI Call Timeout Protection**
  - Added 30-second timeout wrapper (`withTimeout` in `server/utils/ai.ts`) using `Promise.race` pattern
  - Configurable via `AI_TIMEOUT_MS` environment variable, default 30s
  - All direct `ai.models.generateContent` calls replaced across 5 files with timeout-protected `generateContent`
- **Dashboard Performance Optimization**
  - Added `getDashboardData()` method to storage layer: fetches full business→campaign→lead→response hierarchy in 4 batched queries instead of N+1 sequential queries
  - Updated `/api/leads` route to use optimized method
- **Telegram Bot Modularization**
  - Split `server/telegram-bot.ts` (1670→~280 lines) into focused modules under `server/telegram/`:
    - `state.ts` — Shared Maps, constants, and type definitions
    - `analysis.ts` — Post analysis, AI matching, image extraction, business loading
    - `bookmarklets.ts` — Scan token generation, Facebook/LinkedIn bookmarklet code
    - `client-wizard.ts` — Self-service client onboarding wizard flow
    - `admin-commands.ts` — Admin command handlers (/newclient, /removeclient, /keywords, etc.)
    - `callbacks.ts` — Telegram callback query handlers (feedback buttons, Reddit posting)
    - `index.ts` — Barrel export for clean imports
  - Main telegram-bot.ts now serves as slim orchestrator delegating to modules
- **Robustness Refactoring**
  - Created shared utility modules: `server/utils/ai.ts`, `server/utils/html.ts`, `server/utils/feedback.ts`, `server/utils/dedup.ts`
  - Consolidated duplicated code from reddit-monitor, google-alerts-monitor, telegram-bot, and routes
  - Added Zod validation schemas (`leadScoreSchema`, `strategySchema`) with `parseAIJsonWithRetry` for robust AI JSON parsing
  - Added rate limiting via `server/utils/rate-limit.ts` (AI endpoints: 10/min, scan: 15/min, webhook: 60/min)
- **Route Splitting**
  - Split `server/routes.ts` (932→476 lines) into focused modules:
    - `server/routes/admin.ts` — Admin CRUD routes (businesses, campaigns)
    - `server/routes/scan.ts` — Facebook/LinkedIn scan endpoints with shared `handleScanRequest` function
  - FB and LinkedIn scan logic consolidated into single reusable handler, reducing duplication
- **Database Integrity**
  - Added foreign key constraints with cascade delete (campaigns→businesses, leads→campaigns, responses→leads, feedback→responses)

## Previous Changes (Feb 14, 2026)
- **Admin Panel** (`/admin`, `client/src/pages/admin.tsx`)
  - Admin-only web panel at `/admin` accessible via gear icon in dashboard header
  - View all clients/businesses with expandable detail panels
  - Edit business details: name, type, contact info, audience, offering, tone
  - Full campaign management: create, edit, delete campaigns per business
  - Inline tag editors for keywords and target groups (subreddits, Facebook groups)
  - Campaign status toggle (active/paused)
  - Delete business with cascade (removes campaigns, leads, and AI responses)
  - Admin access gated by user ID check middleware
  - API routes: GET/PATCH/DELETE /api/admin/businesses, POST/PATCH/DELETE /api/admin/campaigns
- **Google Alerts RSS Monitor** (`server/google-alerts-monitor.ts`)
  - Monitors Google Alerts RSS feeds for leads across the entire web (Quora, forums, blogs, news)
  - Reuses same pipeline: keyword filter → Gemini Flash scoring → Gemini Pro response → Telegram alert
  - Scans every 2 minutes with dedup key `itemLink::businessId`
  - Strips HTML from feed items, detects source platform (Quora, Reddit, YouTube, Medium, etc.)
  - Telegram commands: /addalert, /alerts, /removealert for feed management
  - Creates `google_alerts` platform campaigns with RSS feed URLs stored in `targetGroups`
  - Inherits business keywords from existing campaigns when creating alert campaign
- **Client Self-Onboarding Wizard** via Telegram deep link (`t.me/kmages_bot?start=setup`)
  - 4-step wizard: business name → what they offer → location/reach → keywords
  - Location supports local (city), national, or global/web-based reach
  - Works for any Telegram user (not just admin)
  - Creates business + Reddit campaign in DB automatically with AI-generated subreddits
  - Sends personalized bookmarklet codes (Facebook + LinkedIn) after setup
  - Sends comprehensive usage guide (auto-scanning, manual scanning, commands)
  - Notifies admin when new client onboards (includes location + subreddits)
- **Web Onboarding → Telegram Flow**
  - Web onboarding completion page directs clients to connect Telegram bot
  - Deep link button opens `t.me/kmages_bot?start=setup` for quick connection
  - Shows "What Happens Next" guide explaining auto-scanning, alerts, bookmarklets, feedback
- **Facebook Spy Glass Bookmarklet** (`client/public/spy-glass.js`)
  - Clients save a bookmark that loads the scanning script on any Facebook Group page
  - Script scans posts as user scrolls, filters by keywords, sends to `/api/fb-scan` endpoint
  - Highlights matched posts with purple outline for visual feedback
  - Shows scan count banner at top of page
  - Bookmarklet includes client's chat ID, business ID, and HMAC token for routing
- **`/api/fb-scan` endpoint** (POST, CORS-enabled) receives Facebook posts from spy-glass
  - Validates HMAC token, business exists, checks keyword match
  - Scores with Gemini Flash, generates response with Gemini Pro
  - Saves leads/responses to DB, sends Telegram alert to client's chat with feedback buttons
- Added `sendTelegramMessageToChat()` function to message any Telegram chat (not just admin)
- Reddit RSS monitor now correctly scans each subreddit once and evaluates all business targets per post
  - Dedup key changed from postId to `postId::businessId` allowing multi-business evaluation
- Improved Context Upgrade: Bot now matches first, only asks "Which group?" when confidence < 6 AND multiple businesses exist
- Added feedback deduplication, TTL on pending context requests
- Added Feedback Loop with inline buttons, feedback-aware response generation
- Leads and AI responses saved to database when generated via Telegram bot
- Screenshot/image support via Gemini Flash OCR
- Admin command center: /newclient, /removeclient, /keywords, /groups, /addalert, /alerts, /removealert
- Primary domain: Gemin-Eye.com

## Previous Changes (Feb 13, 2026)
- Built complete frontend: landing page with animated demo, onboarding wizard, and dashboard
- Built backend API routes with Zod validation, auth protection, and ownership checks
- Added seed data with 3 demo businesses: Doro Mind, Chicago Bocce, LMAITFY.ai
- Fixed authorization on response approval endpoint (ownership verification)
- Added lead scoring endpoint using Gemini 2.5 Flash
- Strategy generation and response crafting use Gemini 2.5 Pro
- Implemented Telegram bot with URL detection, business matching, and response generation
- Added inline keyboard buttons for direct post navigation

## User Preferences

Preferred communication style: Simple, everyday language.
Always push code to GitHub after every commit (requires GitHub remote to be connected).

## System Architecture

### Frontend
- **Framework**: React 18 with TypeScript
- **Routing**: Wouter (lightweight alternative to React Router)
- **State/Data fetching**: TanStack React Query for server state management
- **Styling**: Tailwind CSS with CSS variables for theming (light/dark mode support)
- **UI Components**: shadcn/ui (new-york style) built on Radix UI primitives
- **Forms**: React Hook Form with Zod validation via @hookform/resolvers
- **Build tool**: Vite with HMR support
- **Path aliases**: `@/` maps to `client/src/`, `@shared/` maps to `shared/`
- **Brand colors**: Indigo/violet (hsl 258 70% 55%) with Inter sans-serif font

### Backend
- **Framework**: Express.js running on Node with TypeScript (via tsx)
- **HTTP server**: Node's built-in `http.createServer` wrapping Express
- **API pattern**: RESTful JSON APIs under `/api/` prefix
- **AI Integration**: Google Gemini via `@google/genai` SDK, accessed through Replit's AI Integrations proxy
- **AI Model Usage**:
  - `gemini-2.5-pro`: Strategy generation and response crafting (high quality)
  - `gemini-2.5-flash`: Lead scoring (fast/cheap)
- **Build for production**: esbuild bundles server to `dist/index.cjs`, Vite builds client to `dist/public/`

### Authentication
- **Method**: Replit OpenID Connect (OIDC) authentication via Passport.js
- **Sessions**: Express sessions stored in PostgreSQL via `connect-pg-simple`
- **Required tables**: `sessions` and `users` tables (defined in `shared/models/auth.ts`) — these are mandatory and should not be dropped
- **Session duration**: 1 week TTL
- **Middleware**: `isAuthenticated` middleware protects API routes; user info available at `req.user.claims.sub`

### Database
- **Database**: PostgreSQL (required, connection via `DATABASE_URL` env var)
- **ORM**: Drizzle ORM with `drizzle-zod` for schema-to-Zod validation
- **Schema location**: `shared/schema.ts` (re-exports from `shared/models/auth.ts` and `shared/models/chat.ts`)
- **Migration tool**: Drizzle Kit with `db:push` command for schema synchronization
- **Key tables**:
  - `users` - User accounts (Replit Auth managed)
  - `sessions` - Session storage (Replit Auth managed)
  - `businesses` - User's business profiles with target audience, tone preferences
  - `campaigns` - Monitoring campaigns per business (platform, target groups, keywords)
  - `response_feedback` - Feedback on AI responses (positive, bad_match, too_salesy, wrong_client)
  - `leads` - Discovered high-intent posts from communities
  - `ai_responses` - AI-generated responses to leads with approval status
  - `conversations` / `messages` - Chat functionality tables

### Storage Layer
- **Pattern**: Interface-based storage (`IStorage` in `server/storage.ts`) with `DatabaseStorage` implementation
- **Auth storage**: Separate `IAuthStorage` interface in `server/replit_integrations/auth/storage.ts`
- **Chat storage**: Separate `IChatStorage` interface in `server/replit_integrations/chat/storage.ts`

### Replit Integrations (server/replit_integrations/)
Pre-built modules that provide:
- **auth/**: OIDC authentication setup, session management, user routes
- **batch/**: Batch processing utilities for Gemini API calls with rate limiting, retries, and concurrency control
- **chat/**: Conversation/message CRUD routes and storage for AI chat functionality
- **image/**: Image generation endpoint using Gemini's image model

### Dev vs Production
- **Development**: Vite dev server with HMR proxied through Express, `tsx` runs TypeScript directly
- **Production**: Vite builds static assets to `dist/public/`, esbuild bundles server to `dist/index.cjs`, Express serves static files

## External Dependencies

- **PostgreSQL**: Primary database, required via `DATABASE_URL` environment variable
- **Replit AI Integrations (Gemini)**: AI text and image generation, configured via `AI_INTEGRATIONS_GEMINI_API_KEY` and `AI_INTEGRATIONS_GEMINI_BASE_URL` environment variables
- **Replit OIDC**: Authentication provider via `ISSUER_URL` (defaults to `https://replit.com/oidc`) and `REPL_ID`
- **Session Secret**: `SESSION_SECRET` environment variable required for Express session encryption
- **Google Fonts**: Inter, Playfair Display, JetBrains Mono
- **react-icons**: Social media icons (Facebook, Reddit) via `react-icons/si`


