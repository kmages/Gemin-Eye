{"schemaVersion":1,"gitHash":"82e047b97efebe736e7b2c02f73db442c90b9547","writtenAt":"2026-02-21T14:36:30.843Z","data":{"vulnerabilities":[{"id":"GHSA-2g4f-4pwh-qvx6@ajv-6.12.6","package":{"name":"ajv","version":"6.12.6","ecosystem":"npm","purl":"pkg:npm/ajv"},"severity":{"level":"moderate","type":"CVSS_V4","vector":"CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:N/VI:N/VA:L/SC:N/SI:N/SA:N/E:P"},"affectedVersions":{"ranges":[{"introduced":"7.0.0-alpha.0","fixed":"8.18.0"}]},"fix":{"available":true,"version":"8.18.0","requiresMajorUpdate":true},"details":{"title":"ajv has ReDoS when using `$data` option","description":"ajv (Another JSON Schema Validator) through version 8.17.1 is vulnerable to Regular Expression Denial of Service (ReDoS) when the `$data` option is enabled. The pattern keyword accepts runtime data via JSON Pointer syntax (`$data` reference), which is passed directly to the JavaScript `RegExp()` constructor without validation. An attacker can inject a malicious regex pattern (e.g., `\\\"^(a|a)*$\\\"`) combined with crafted input to cause catastrophic backtracking. A 31-character payload causes approximately 44 seconds of CPU blocking, with each additional character doubling execution time. This enables complete denial of service with a single HTTP request against any API using ajv with `$data`: true for dynamic schema validation.","references":[{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-69873"},{"type":"WEB","url":"https://github.com/ajv-validator/ajv/pull/2586"},{"type":"WEB","url":"https://github.com/ajv-validator/ajv/pull/2588"},{"type":"WEB","url":"https://github.com/ajv-validator/ajv/commit/720a23fa453ffae8340e92c9b0fe886c54cfe0d5"},{"type":"WEB","url":"https://github.com/EthanKim88/ethan-cve-disclosures/blob/main/CVE-2025-69873-ajv-ReDoS.md"},{"type":"PACKAGE","url":"https://github.com/ajv-validator/ajv"},{"type":"WEB","url":"https://github.com/ajv-validator/ajv/releases/tag/v6.14.0"},{"type":"WEB","url":"https://github.com/ajv-validator/ajv/releases/tag/v8.18.0"}],"aliases":["CVE-2025-69873"]},"source":{"scanner":"osv-scanner","scannedAt":"2026-02-21T14:36:15.112Z"}},{"id":"GHSA-fjxv-7rqg-78g4@form-data-2.3.3","package":{"name":"form-data","version":"2.3.3","ecosystem":"npm","purl":"pkg:npm/form-data"},"severity":{"level":"critical","type":"CVSS_V4","vector":"CVSS:4.0/AV:N/AC:H/AT:N/PR:N/UI:N/VC:H/VI:H/VA:N/SC:H/SI:H/SA:N"},"affectedVersions":{"ranges":[{"introduced":"0","fixed":"2.5.4"}]},"fix":{"available":true,"version":"2.5.4","requiresMajorUpdate":false},"details":{"title":"form-data uses unsafe random function in form-data for choosing boundary","description":"### Summary\n\nform-data uses `Math.random()` to select a boundary value for multipart form-encoded data. This can lead to a security issue if an attacker:\n1. can observe other values produced by Math.random in the target application, and\n2. can control one field of a request made using form-data\n\nBecause the values of Math.random() are pseudo-random and predictable (see: https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f), an attacker who can observe a few sequential values can determine the state of the PRNG and predict future values, includes those used to generate form-data's boundary value. The allows the attacker to craft a value that contains a boundary value, allowing them to inject additional parameters into the request.\n\nThis is largely the same vulnerability as was [recently found in `undici`](https://hackerone.com/reports/2913312) by [`parrot409`](https://hackerone.com/parrot409?type=user) -- I'm not affiliated with that researcher but want to give credit where credit is due! My PoC is largely based on their work.\n\n### Details\n\nThe culprit is this line here: https://github.com/form-data/form-data/blob/426ba9ac440f95d1998dac9a5cd8d738043b048f/lib/form_data.js#L347\n\nAn attacker who is able to predict the output of Math.random() can predict this boundary value, and craft a payload that contains the boundary value, followed by another, fully attacker-controlled field. This is roughly equivalent to any sort of improper escaping vulnerability, with the caveat that the attacker must find a way to observe other Math.random() values generated by the application to solve for the state of the PRNG. However, Math.random() is used in all sorts of places that might be visible to an attacker (including by form-data itself, if the attacker can arrange for the vulnerable application to make a request to an attacker-controlled server using form-data, such as a user-controlled webhook -- the attacker could observe the boundary values from those requests to observe the Math.random() outputs). A common example would be a `x-request-id` header added by the server. These sorts of headers are often used for distributed tracing, to correlate errors across the frontend and backend. `Math.random()` is a fine place to get these sorts of IDs (in fact, [opentelemetry uses Math.random for this purpose](https://github.com/open-telemetry/opentelemetry-js/blob/2053f0d3a44631ade77ea04f656056a2c8a2ae76/packages/opentelemetry-sdk-trace-base/src/platform/node/RandomIdGenerator.ts#L22))\n\n### PoC\n\nPoC here: https://github.com/benweissmann/CVE-2025-7783-poc\n\nInstructions are in that repo. It's based on the PoC from https://hackerone.com/reports/2913312 but simplified somewhat; the vulnerable application has a more direct side-channel from which to observe Math.random() values (a separate endpoint that happens to include a randomly-generated request ID). \n\n### Impact\n\nFor an application to be vulnerable, it must:\n- Use `form-data` to send data including user-controlled data to some other system. The attacker must be able to do something malicious by adding extra parameters (that were not intended to be user-controlled) to this request. Depending on the target system's handling of repeated parameters, the attacker might be able to overwrite values in addition to appending values (some multipart form handlers deal with repeats by overwriting values instead of representing them as an array)\n- Reveal values of Math.random(). It's easiest if the attacker can observe multiple sequential values, but more complex math could recover the PRNG state to some degree of confidence with non-sequential values. \n\nIf an application is vulnerable, this allows an attacker to make arbitrary requests to internal systems.","references":[{"type":"WEB","url":"https://github.com/form-data/form-data/security/advisories/GHSA-fjxv-7rqg-78g4"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-7783"},{"type":"WEB","url":"https://github.com/form-data/form-data/commit/3d1723080e6577a66f17f163ecd345a21d8d0fd0"},{"type":"WEB","url":"https://github.com/benweissmann/CVE-2025-7783-poc"},{"type":"PACKAGE","url":"https://github.com/form-data/form-data"},{"type":"WEB","url":"https://lists.debian.org/debian-lts-announce/2025/07/msg00023.html"}],"aliases":["CVE-2025-7783"]},"source":{"scanner":"osv-scanner","scannedAt":"2026-02-21T14:36:15.113Z"}},{"id":"GHSA-xxjr-mmjv-4gpg@lodash-4.17.21","package":{"name":"lodash","version":"4.17.21","ecosystem":"npm","purl":"pkg:npm/lodash"},"severity":{"level":"moderate","type":"CVSS_V3","vector":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L"},"affectedVersions":{"ranges":[{"introduced":"4.0.0","fixed":"4.17.23"}]},"fix":{"available":true,"version":"4.17.23","requiresMajorUpdate":false},"details":{"title":"Lodash has Prototype Pollution Vulnerability in `_.unset` and `_.omit` functions","description":"### Impact\n\nLodash versions 4.0.0 through 4.17.22 are vulnerable to prototype pollution in the `_.unset` and `_.omit` functions. An attacker can pass crafted paths which cause Lodash to delete methods from global prototypes. \n\nThe issue permits deletion of properties but does not allow overwriting their original behavior.  \n\n### Patches\n\nThis issue is patched on 4.17.23.","references":[{"type":"WEB","url":"https://github.com/lodash/lodash/security/advisories/GHSA-xxjr-mmjv-4gpg"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-13465"},{"type":"WEB","url":"https://github.com/lodash/lodash/commit/edadd452146f7e4bad4ea684e955708931d84d81"},{"type":"PACKAGE","url":"https://github.com/lodash/lodash"}],"aliases":["CVE-2025-13465"]},"source":{"scanner":"osv-scanner","scannedAt":"2026-02-21T14:36:15.114Z"}},{"id":"GHSA-w7fw-mjwx-w883@qs-6.14.1","package":{"name":"qs","version":"6.14.1","ecosystem":"npm","purl":"pkg:npm/qs"},"severity":{"level":"low","type":"CVSS_V3","vector":"CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L"},"affectedVersions":{"ranges":[{"introduced":"6.7.0","fixed":"6.14.2"}]},"fix":{"available":true,"version":"6.14.2","requiresMajorUpdate":false},"details":{"title":"qs's arrayLimit bypass in comma parsing allows denial of service","description":"### Summary\nThe `arrayLimit` option in qs does not enforce limits for comma-separated values when `comma: true` is enabled, allowing attackers to cause denial-of-service via memory exhaustion. This is a bypass of the array limit enforcement, similar to the bracket notation bypass addressed in GHSA-6rw7-vpxm-498p (CVE-2025-15284).\n\n### Details\nWhen the `comma` option is set to `true` (not the default, but configurable in applications), qs allows parsing comma-separated strings as arrays (e.g., `?param=a,b,c` becomes `['a', 'b', 'c']`). However, the limit check for `arrayLimit` (default: 20) and the optional throwOnLimitExceeded occur after the comma-handling logic in `parseArrayValue`, enabling a bypass. This permits creation of arbitrarily large arrays from a single parameter, leading to excessive memory allocation.\n\n**Vulnerable code** (lib/parse.js: lines ~40-50):\n```js\nif (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n    return val.split(',');\n}\n\nif (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n    throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n}\n\nreturn val;\n```\nThe `split(',')` returns the array immediately, skipping the subsequent limit check. Downstream merging via `utils.combine` does not prevent allocation, even if it marks overflows for sparse arrays.This discrepancy allows attackers to send a single parameter with millions of commas (e.g., `?param=,,,,,,,,...`), allocating massive arrays in memory without triggering limits. It bypasses the intent of `arrayLimit`, which is enforced correctly for indexed (`a[0]=`) and bracket (`a[]=`) notations (the latter fixed in v6.14.1 per GHSA-6rw7-vpxm-498p).\n\n### PoC\n**Test 1 - Basic bypass:**\n```\nnpm install qs\n```\n\n```js\nconst qs = require('qs');\n\nconst payload = 'a=' + ','.repeat(25);  // 26 elements after split (bypasses arrayLimit: 5)\nconst options = { comma: true, arrayLimit: 5, throwOnLimitExceeded: true };\n\ntry {\n  const result = qs.parse(payload, options);\n  console.log(result.a.length);  // Outputs: 26 (bypass successful)\n} catch (e) {\n  console.log('Limit enforced:', e.message);  // Not thrown\n}\n```\n**Configuration:**\n- `comma: true`\n- `arrayLimit: 5`\n- `throwOnLimitExceeded: true`\n\nExpected: Throws \"Array limit exceeded\" error.\nActual: Parses successfully, creating an array of length 26.\n\n\n### Impact\nDenial of Service (DoS) via memory exhaustion.\n\n### Suggested Fix\nMove the `arrayLimit` check before the comma split in `parseArrayValue`, and enforce it on the resulting array length. Use `currentArrayLength` (already calculated upstream) for consistency with bracket notation fixes.\n\n**Current code** (lib/parse.js: lines ~40-50):\n```js\nif (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n    return val.split(',');\n}\n\nif (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n    throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n}\n\nreturn val;\n```\n\n**Fixed code:**\n```js\nif (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\n    const splitArray = val.split(',');\n    if (splitArray.length > options.arrayLimit - currentArrayLength) {  // Check against remaining limit\n        if (options.throwOnLimitExceeded) {\n            throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n        } else {\n            // Optionally convert to object or truncate, per README\n            return splitArray.slice(0, options.arrayLimit - currentArrayLength);\n        }\n    }\n    return splitArray;\n}\n\nif (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n    throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n}\n\nreturn val;\n```\nThis aligns behavior with indexed and bracket notations, reuses `currentArrayLength`, and respects `throwOnLimitExceeded`. Update README to note the consistent enforcement.","references":[{"type":"WEB","url":"https://github.com/ljharb/qs/security/advisories/GHSA-w7fw-mjwx-w883"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2026-2391"},{"type":"WEB","url":"https://github.com/ljharb/qs/commit/f6a7abff1f13d644db9b05fe4f2c98ada6bf8482"},{"type":"PACKAGE","url":"https://github.com/ljharb/qs"}],"aliases":["CVE-2026-2391"]},"source":{"scanner":"osv-scanner","scannedAt":"2026-02-21T14:36:15.114Z"}},{"id":"GHSA-6rw7-vpxm-498p@qs-6.5.5","package":{"name":"qs","version":"6.5.5","ecosystem":"npm","purl":"pkg:npm/qs"},"severity":{"level":"high","type":"CVSS_V3","vector":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"},"affectedVersions":{"ranges":[{"introduced":"0","fixed":"6.14.1"}]},"fix":{"available":true,"version":"6.14.1","requiresMajorUpdate":false},"details":{"title":"qs's arrayLimit bypass in its bracket notation allows DoS via memory exhaustion","description":"### Summary\n\nThe `arrayLimit` option in qs does not enforce limits for bracket notation (`a[]=1&a[]=2`), allowing attackers to cause denial-of-service via memory exhaustion. Applications using `arrayLimit` for DoS protection are vulnerable.\n\n### Details\n\nThe `arrayLimit` option only checks limits for indexed notation (`a[0]=1&a[1]=2`) but completely bypasses it for bracket notation (`a[]=1&a[]=2`).\n\n**Vulnerable code** (`lib/parse.js:159-162`):\n```javascript\nif (root === '[]' && options.parseArrays) {\n    obj = utils.combine([], leaf);  // No arrayLimit check\n}\n```\n\n**Working code** (`lib/parse.js:175`):\n```javascript\nelse if (index <= options.arrayLimit) {  // Limit checked here\n    obj = [];\n    obj[index] = leaf;\n}\n```\n\nThe bracket notation handler at line 159 uses `utils.combine([], leaf)` without validating against `options.arrayLimit`, while indexed notation at line 175 checks `index <= options.arrayLimit` before creating arrays.\n\n### PoC\n\n**Test 1 - Basic bypass:**\n```bash\nnpm install qs\n```\n\n```javascript\nconst qs = require('qs');\nconst result = qs.parse('a[]=1&a[]=2&a[]=3&a[]=4&a[]=5&a[]=6', { arrayLimit: 5 });\nconsole.log(result.a.length);  // Output: 6 (should be max 5)\n```\n\n**Test 2 - DoS demonstration:**\n```javascript\nconst qs = require('qs');\nconst attack = 'a[]=' + Array(10000).fill('x').join('&a[]=');\nconst result = qs.parse(attack, { arrayLimit: 100 });\nconsole.log(result.a.length);  // Output: 10000 (should be max 100)\n```\n\n**Configuration:**\n- `arrayLimit: 5` (test 1) or `arrayLimit: 100` (test 2)\n- Use bracket notation: `a[]=value` (not indexed `a[0]=value`)\n\n### Impact\n\nDenial of Service via memory exhaustion. Affects applications using `qs.parse()` with user-controlled input and `arrayLimit` for protection.\n\n**Attack scenario:**\n1. Attacker sends HTTP request: `GET /api/search?filters[]=x&filters[]=x&...&filters[]=x` (100,000+ times)\n2. Application parses with `qs.parse(query, { arrayLimit: 100 })`\n3. qs ignores limit, parses all 100,000 elements into array\n4. Server memory exhausted â†’ application crashes or becomes unresponsive\n5. Service unavailable for all users\n\n**Real-world impact:**\n- Single malicious request can crash server\n- No authentication required\n- Easy to automate and scale\n- Affects any endpoint parsing query strings with bracket notation\n\n### Suggested Fix\n\nAdd `arrayLimit` validation to the bracket notation handler. The code already calculates `currentArrayLength` at line 147-151, but it's not used in the bracket notation handler at line 159.\n\n**Current code** (`lib/parse.js:159-162`):\n```javascript\nif (root === '[]' && options.parseArrays) {\n    obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n        ? []\n        : utils.combine([], leaf);  // No arrayLimit check\n}\n```\n\n**Fixed code**:\n```javascript\nif (root === '[]' && options.parseArrays) {\n    // Use currentArrayLength already calculated at line 147-151\n    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n    }\n    \n    // If limit exceeded and not throwing, convert to object (consistent with indexed notation behavior)\n    if (currentArrayLength >= options.arrayLimit) {\n        obj = options.plainObjects ? { __proto__: null } : {};\n        obj[currentArrayLength] = leaf;\n    } else {\n        obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n            ? []\n            : utils.combine([], leaf);\n    }\n}\n```\n\nThis makes bracket notation behaviour consistent with indexed notation, enforcing `arrayLimit` and converting to object when limit is exceeded (per README documentation).","references":[{"type":"WEB","url":"https://github.com/ljharb/qs/security/advisories/GHSA-6rw7-vpxm-498p"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-15284"},{"type":"WEB","url":"https://github.com/ljharb/qs/commit/3086902ecf7f088d0d1803887643ac6c03d415b9"},{"type":"PACKAGE","url":"https://github.com/ljharb/qs"}],"aliases":["CVE-2025-15284"]},"source":{"scanner":"osv-scanner","scannedAt":"2026-02-21T14:36:15.114Z"}},{"id":"GHSA-p8p7-x288-28g6@request-2.88.2","package":{"name":"request","version":"2.88.2","ecosystem":"npm","purl":"pkg:npm/request"},"severity":{"level":"moderate","type":"CVSS_V3","vector":"CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N"},"affectedVersions":{"ranges":[{"introduced":"0","lastAffected":"2.88.2"}]},"details":{"title":"Server-Side Request Forgery in Request","description":"The `request` package through 2.88.2 for Node.js and the `@cypress/request` package prior to 3.0.0 allow a bypass of SSRF mitigations via an attacker-controller server that does a cross-protocol redirect (HTTP to HTTPS, or HTTPS to HTTP).\n\nNOTE: The `request` package is no longer supported by the maintainer.","references":[{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2023-28155"},{"type":"WEB","url":"https://github.com/request/request/issues/3442"},{"type":"WEB","url":"https://github.com/cypress-io/request/pull/28"},{"type":"WEB","url":"https://github.com/github/advisory-database/pull/2500"},{"type":"WEB","url":"https://github.com/request/request/pull/3444"},{"type":"WEB","url":"https://github.com/cypress-io/request/commit/c5bcf21d40fb61feaff21a0e5a2b3934a440024f"},{"type":"WEB","url":"https://doyensec.com/resources/Doyensec_Advisory_RequestSSRF_Q12023.pdf"},{"type":"WEB","url":"https://github.com/cypress-io/request/blob/master/lib/redirect.js#L116"},{"type":"WEB","url":"https://github.com/cypress-io/request/releases/tag/v3.0.0"},{"type":"PACKAGE","url":"https://github.com/request/request"},{"type":"WEB","url":"https://github.com/request/request/blob/master/lib/redirect.js#L111"},{"type":"WEB","url":"https://security.netapp.com/advisory/ntap-20230413-0007"}],"aliases":["CVE-2023-28155"]},"source":{"scanner":"osv-scanner","scannedAt":"2026-02-21T14:36:15.114Z"}},{"id":"GHSA-72xf-g2v4-qvf3@tough-cookie-2.5.0","package":{"name":"tough-cookie","version":"2.5.0","ecosystem":"npm","purl":"pkg:npm/tough-cookie"},"severity":{"level":"moderate","type":"CVSS_V3","vector":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N"},"affectedVersions":{"ranges":[{"introduced":"0","fixed":"4.1.3"}]},"fix":{"available":true,"version":"4.1.3","requiresMajorUpdate":true},"details":{"title":"tough-cookie Prototype Pollution vulnerability","description":"Versions of the package tough-cookie before 4.1.3 are vulnerable to Prototype Pollution due to improper handling of Cookies when using CookieJar in `rejectPublicSuffixes=false` mode. This issue arises from the manner in which the objects are initialized.","references":[{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2023-26136"},{"type":"WEB","url":"https://github.com/salesforce/tough-cookie/issues/282"},{"type":"WEB","url":"https://github.com/salesforce/tough-cookie/commit/12d474791bb856004e858fdb1c47b7608d09cf6e"},{"type":"PACKAGE","url":"https://github.com/salesforce/tough-cookie"},{"type":"WEB","url":"https://github.com/salesforce/tough-cookie/releases/tag/v4.1.3"},{"type":"WEB","url":"https://lists.debian.org/debian-lts-announce/2023/07/msg00010.html"},{"type":"WEB","url":"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3HUE6ZR5SL73KHL7XUPAOEL6SB7HUDT2"},{"type":"WEB","url":"https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6PVVPNSAGSDS63HQ74PJ7MZ3MU5IYNVZ"},{"type":"WEB","url":"https://security.netapp.com/advisory/ntap-20240621-0006"},{"type":"WEB","url":"https://security.snyk.io/vuln/SNYK-JS-TOUGHCOOKIE-5672873"}],"aliases":["CVE-2023-26136"]},"source":{"scanner":"osv-scanner","scannedAt":"2026-02-21T14:36:15.114Z"}},{"id":"GHSA-3h5v-q93c-6h6q@ws-3.3.3","package":{"name":"ws","version":"3.3.3","ecosystem":"npm","purl":"pkg:npm/ws"},"severity":{"level":"high","type":"CVSS_V3","vector":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"},"affectedVersions":{"ranges":[{"introduced":"2.1.0","fixed":"5.2.4"}]},"fix":{"available":true,"version":"5.2.4","requiresMajorUpdate":true},"details":{"title":"ws affected by a DoS when handling a request with many HTTP headers","description":"### Impact\n\nA request with a number of headers exceeding the[`server.maxHeadersCount`][] threshold could be used to crash a ws server.\n\n### Proof of concept\n\n```js\nconst http = require('http');\nconst WebSocket = require('ws');\n\nconst wss = new WebSocket.Server({ port: 0 }, function () {\n  const chars = \"!#$%&'*+-.0123456789abcdefghijklmnopqrstuvwxyz^_`|~\".split('');\n  const headers = {};\n  let count = 0;\n\n  for (let i = 0; i < chars.length; i++) {\n    if (count === 2000) break;\n\n    for (let j = 0; j < chars.length; j++) {\n      const key = chars[i] + chars[j];\n      headers[key] = 'x';\n\n      if (++count === 2000) break;\n    }\n  }\n\n  headers.Connection = 'Upgrade';\n  headers.Upgrade = 'websocket';\n  headers['Sec-WebSocket-Key'] = 'dGhlIHNhbXBsZSBub25jZQ==';\n  headers['Sec-WebSocket-Version'] = '13';\n\n  const request = http.request({\n    headers: headers,\n    host: '127.0.0.1',\n    port: wss.address().port\n  });\n\n  request.end();\n});\n```\n\n### Patches\n\nThe vulnerability was fixed in ws@8.17.1 (https://github.com/websockets/ws/commit/e55e5106f10fcbaac37cfa89759e4cc0d073a52c) and backported to ws@7.5.10 (https://github.com/websockets/ws/commit/22c28763234aa75a7e1b76f5c01c181260d7917f), ws@6.2.3 (https://github.com/websockets/ws/commit/eeb76d313e2a00dd5247ca3597bba7877d064a63), and ws@5.2.4 (https://github.com/websockets/ws/commit/4abd8f6de4b0b65ef80b3ff081989479ed93377e)\n\n### Workarounds\n\nIn vulnerable versions of ws, the issue can be mitigated in the following ways:\n\n1. Reduce the maximum allowed length of the request headers using the [`--max-http-header-size=size`][] and/or the [`maxHeaderSize`][] options so that no more headers than the `server.maxHeadersCount` limit can be sent.\n2. Set `server.maxHeadersCount` to `0` so that no limit is applied.\n\n### Credits\n\nThe vulnerability was reported by [Ryan LaPointe](https://github.com/rrlapointe) in https://github.com/websockets/ws/issues/2230.\n\n### References\n\n- https://github.com/websockets/ws/issues/2230\n- https://github.com/websockets/ws/pull/2231\n\n[`--max-http-header-size=size`]: https://nodejs.org/api/cli.html#--max-http-header-sizesize\n[`maxHeaderSize`]: https://nodejs.org/api/http.html#httpcreateserveroptions-requestlistener\n[`server.maxHeadersCount`]: https://nodejs.org/api/http.html#servermaxheaderscount\n","references":[{"type":"WEB","url":"https://github.com/websockets/ws/security/advisories/GHSA-3h5v-q93c-6h6q"},{"type":"WEB","url":"https://github.com/websockets/ws/issues/2230"},{"type":"WEB","url":"https://github.com/websockets/ws/pull/2231"},{"type":"WEB","url":"https://github.com/websockets/ws/commit/22c28763234aa75a7e1b76f5c01c181260d7917f"},{"type":"WEB","url":"https://github.com/websockets/ws/commit/4abd8f6de4b0b65ef80b3ff081989479ed93377e"},{"type":"WEB","url":"https://github.com/websockets/ws/commit/e55e5106f10fcbaac37cfa89759e4cc0d073a52c"},{"type":"WEB","url":"https://github.com/websockets/ws/commit/eeb76d313e2a00dd5247ca3597bba7877d064a63"},{"type":"PACKAGE","url":"https://github.com/websockets/ws"}],"aliases":["CVE-2024-37890"]},"source":{"scanner":"osv-scanner","scannedAt":"2026-02-21T14:36:15.114Z"}}],"metadata":{"vulnerabilities":{"info":0,"low":1,"moderate":4,"high":2,"critical":1}}}}